<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lxy&#39;s blog</title>
  
  <subtitle>Achieve my dream ...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https:LotusLeaves.github.io/"/>
  <updated>2019-08-15T13:41:13.454Z</updated>
  <id>https:LotusLeaves.github.io/</id>
  
  <author>
    <name>lxy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>洛谷 P2279 [HNOI2003]消防局的设立 题解</title>
    <link href="https:LotusLeaves.github.io/2019/08/15/%E6%B4%9B%E8%B0%B7%20P2279%20%5BHNOI2003%5D%E6%B6%88%E9%98%B2%E5%B1%80%E7%9A%84%E8%AE%BE%E7%AB%8B%20%E9%A2%98%E8%A7%A3/"/>
    <id>https:LotusLeaves.github.io/2019/08/15/洛谷 P2279 [HNOI2003]消防局的设立 题解/</id>
    <published>2019-08-15T13:29:08.443Z</published>
    <updated>2019-08-15T13:41:13.454Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>给定一棵 $n$ 个节点的树，定义树上两个节点 $a$、$b$ 的距离为从 $a$ 走到 $b$ 需要经过的边数。在任意一个节点建立消防站，可以覆盖到与其距离不超过 $2$ 的所有节点。求覆盖到树上每个节点最少需要的消防站个数。</p><p>数据范围：$n&lt;=1000$</p><a id="more"></a><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><h3 id="树形dp"><a href="#树形dp" class="headerlink" title="树形dp"></a>树形dp</h3><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code 1"></a>Code 1</h3><p><strong>树形dp的做法先咕着，以后再补qwq</strong></p><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><p>每次选择一个深度最深的节点，想要覆盖这个节点，就需要在它的 兄弟/父亲/爷爷 中建立一个消防站。画图可以发现在其爷爷节点建立消防站可以覆盖到所有其他节点。</p><p>对所有节点进行排序，顺序遍历，取出 <strong>没有被覆盖过</strong> 的节点，在其爷爷节点建立一个消防站。</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code 2"></a>Code 2</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2000</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> nxt, to;</span><br><span class="line">&#125; e[N];</span><br><span class="line"><span class="keyword">int</span> n, a, cnt = <span class="number">0</span>, max_d = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> vis[N], d[N], head[N], f[N], vis2[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(); <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123; <span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>; c = getchar(); &#125;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) &#123; x = x * <span class="number">10</span> + c - <span class="number">48</span>; c = getchar(); &#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++cnt] = (edge) &#123; head[x], y &#125;;</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[x] = fa; d[x] = d[fa] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v != fa) dfs(v, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> tot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tot &gt; <span class="number">2</span>) <span class="keyword">return</span> ;</span><br><span class="line">    vis[x] = vis2[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!vis2[v]) dfs2(v, tot + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> d[a] &gt; d[b]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    sort(b + <span class="number">1</span>, b + n + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[b[i]] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">memset</span>(vis2, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis2));</span><br><span class="line">        ans++;</span><br><span class="line">        dfs2(f[f[b[i]]], <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a = read();</span><br><span class="line">        b[i] = i;</span><br><span class="line">        add(a, i + <span class="number">1</span>); add(i + <span class="number">1</span>, a);</span><br><span class="line">    &#125;</span><br><span class="line">    b[n] = n;</span><br><span class="line">    solve();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;p&gt;给定一棵 $n$ 个节点的树，定义树上两个节点 $a$、$b$ 的距离为从 $a$ 走到 $b$ 需要经过的边数。在任意一个节点建立消防站，可以覆盖到与其距离不超过 $2$ 的所有节点。求覆盖到树上每个节点最少需要的消防站个数。&lt;/p&gt;
&lt;p&gt;数据范围：$n&amp;lt;=1000$&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https:LotusLeaves.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="dp" scheme="https:LotusLeaves.github.io/tags/dp/"/>
    
      <category term="树形dp" scheme="https:LotusLeaves.github.io/tags/%E6%A0%91%E5%BD%A2dp/"/>
    
      <category term="贪心" scheme="https:LotusLeaves.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>洛谷 P1026 统计单词个数 题解</title>
    <link href="https:LotusLeaves.github.io/2019/08/15/%E6%B4%9B%E8%B0%B7%20P1026%20%E7%BB%9F%E8%AE%A1%E5%8D%95%E8%AF%8D%E4%B8%AA%E6%95%B0%20%E9%A2%98%E8%A7%A3/"/>
    <id>https:LotusLeaves.github.io/2019/08/15/洛谷 P1026 统计单词个数 题解/</id>
    <published>2019-08-15T13:04:50.310Z</published>
    <updated>2019-08-15T13:24:40.530Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>给出一个由小写字母组成的字符串（$p$ 行，每行 $20$ 个字母)，以及 $s$ 个单词。将此字母串分成 $k$ 份，使每份中包含的单词数之和最大（单词可以重叠，但其首字母不能重复使用）。</p><p>数据范围：$p&lt;=10, 1&lt;k&lt;=40, 1&lt;=s&lt;=6$</p><a id="more"></a><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>设 $f[i][j]$ 为前 $i$ 个字符分成 $j$ 段的最大单词数；$cnt[i][j]$ 表示在 <strong>不考虑断开</strong> 的前提下 $[i,j]$ 区间的单词数。</p><p>首先预处理处 $cnt$ 数组。</p><p>转移方程：$f[i][j]=max(f[k][j-1]+cnt[k+1][i])$ （$k$ 为枚举上次断开的位置）</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str, s = <span class="string">""</span>, w[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> p, q, n, f[<span class="number">300</span>][<span class="number">50</span>], cnt[<span class="number">300</span>][<span class="number">300</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; w[y].size(); i++)</span><br><span class="line">        <span class="keyword">if</span>(s[i + x] != w[y][i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; s.size(); j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt;= j; k++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> h = <span class="number">1</span>; h &lt;= n; h++)</span><br><span class="line">                    <span class="keyword">if</span>(k + w[h].size() - <span class="number">1</span> &lt;= j &amp;&amp; get(k, h))</span><br><span class="line">                    &#123;</span><br><span class="line">                        cnt[i][j]++;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;p, &amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= p; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">        s += str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">cin</span> &gt;&gt; w[i];</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">    solve();</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= min(i + <span class="number">1</span>, q); j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = j - <span class="number">2</span>; k &lt; i; k++)</span><br><span class="line">                f[i][j] = max(f[i][j], f[k][j - <span class="number">1</span>] + cnt[k + <span class="number">1</span>][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, f[s.size() - <span class="number">1</span>][q]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;p&gt;给出一个由小写字母组成的字符串（$p$ 行，每行 $20$ 个字母)，以及 $s$ 个单词。将此字母串分成 $k$ 份，使每份中包含的单词数之和最大（单词可以重叠，但其首字母不能重复使用）。&lt;/p&gt;
&lt;p&gt;数据范围：$p&amp;lt;=10, 1&amp;lt;k&amp;lt;=40, 1&amp;lt;=s&amp;lt;=6$&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https:LotusLeaves.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="dp" scheme="https:LotusLeaves.github.io/tags/dp/"/>
    
      <category term="字符串" scheme="https:LotusLeaves.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>洛谷 P1220 关路灯 题解</title>
    <link href="https:LotusLeaves.github.io/2019/08/15/%E6%B4%9B%E8%B0%B7%20P1220%20%E5%85%B3%E8%B7%AF%E7%81%AF%20%E9%A2%98%E8%A7%A3/"/>
    <id>https:LotusLeaves.github.io/2019/08/15/洛谷 P1220 关路灯 题解/</id>
    <published>2019-08-15T00:24:10.239Z</published>
    <updated>2019-08-15T13:26:13.460Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>有 $n$ 盏路灯，每盏路灯有坐标（单位 $m$）和功率（单位 $J$）。从第 $c$ 盏路灯开始，可以向左或向右关闭路灯。速度是 $1m/s$。求所有路灯的最少耗电。输入保证坐标单调递增。</p><p>数据范围：$1&lt;=n&lt;=50$</p><a id="more"></a><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>设 $f[i][j][0/1]$ 为已经关闭区间 $[i,j]$ 所有灯，此时站在 左端点 $/$ 右端点 的最小耗电。</p><p>设 $d(i,j)$ 为第 $i$ 盏路灯和第 $j$ 盏路灯之间的距离，$w(i,j)$ 为 <strong>除了</strong> $[i,j]$ 区间所有灯每秒钟的耗电总和。转移方程：</p><p>$f[i][j][0]=max(f[i+1][j][0]+d(i,i+1)w(i+1,j),f[i+1][j][1]+d(i,j)w(i+1,j))$<br>$f[i][j][1]=max(f[i][j-1][0]+d(i,j)w(i,j-1),f[i][j-1][1]+d(j-1,j)w(j,j-1))$</p><p>使用前缀和维护耗电之和。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">60</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">light</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> pos, w;</span><br><span class="line">&#125; a[N];</span><br><span class="line"><span class="keyword">int</span> n, c, sum[N], f[N][N][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;c);</span><br><span class="line">    sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a[i].pos, &amp;a[i].w);</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + a[i].w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[c][c][<span class="number">0</span>] = f[c][c][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>; l + i &lt;= n; l++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> r = l + i;</span><br><span class="line">            <span class="keyword">int</span> d1 = sum[n] - sum[r] + sum[l];</span><br><span class="line">            <span class="keyword">int</span> d2 = sum[n] - sum[r - <span class="number">1</span>] + sum[l - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(l &gt; c || r &lt; c) <span class="keyword">continue</span>;</span><br><span class="line">            f[l][r][<span class="number">0</span>] = min(f[l][r][<span class="number">0</span>], f[l + <span class="number">1</span>][r][<span class="number">0</span>] + (a[l + <span class="number">1</span>].pos - a[l].pos) * d1);</span><br><span class="line">            f[l][r][<span class="number">0</span>] = min(f[l][r][<span class="number">0</span>], f[l + <span class="number">1</span>][r][<span class="number">1</span>] + (a[r].pos - a[l].pos) * d1);</span><br><span class="line">            f[l][r][<span class="number">1</span>] = min(f[l][r][<span class="number">1</span>], f[l][r - <span class="number">1</span>][<span class="number">1</span>] + (a[r].pos - a[r - <span class="number">1</span>].pos) * d2);</span><br><span class="line">            f[l][r][<span class="number">1</span>] = min(f[l][r][<span class="number">1</span>], f[l][r - <span class="number">1</span>][<span class="number">0</span>] + (a[r].pos - a[l].pos) * d2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, min(f[<span class="number">1</span>][n][<span class="number">0</span>], f[<span class="number">1</span>][n][<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;p&gt;有 $n$ 盏路灯，每盏路灯有坐标（单位 $m$）和功率（单位 $J$）。从第 $c$ 盏路灯开始，可以向左或向右关闭路灯。速度是 $1m/s$。求所有路灯的最少耗电。输入保证坐标单调递增。&lt;/p&gt;
&lt;p&gt;数据范围：$1&amp;lt;=n&amp;lt;=50$&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https:LotusLeaves.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="dp" scheme="https:LotusLeaves.github.io/tags/dp/"/>
    
      <category term="区间dp" scheme="https:LotusLeaves.github.io/tags/%E5%8C%BA%E9%97%B4dp/"/>
    
  </entry>
  
  <entry>
    <title>bzoj 1001 [BeiJing2006]狼抓兔子 题解</title>
    <link href="https:LotusLeaves.github.io/2019/07/26/bzoj%201001%20%5BBeiJing2006%5D%E7%8B%BC%E6%8A%93%E5%85%94%E5%AD%90%20%E9%A2%98%E8%A7%A3/"/>
    <id>https:LotusLeaves.github.io/2019/07/26/bzoj 1001 [BeiJing2006]狼抓兔子 题解/</id>
    <published>2019-07-26T01:40:02.943Z</published>
    <updated>2019-08-14T14:32:26.945Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>给定一 $n*m$ 的网格图。每条边有一个流量，兔子从左上角 $(1,1)$ 跑到右下角 $(n,m)$。流量为 $k$ 的边需要 $k$ 匹狼才能堵住。</p><p>求把兔子一网打尽所需的最少的狼。</p><a id="more"></a><p>如图：</p><p><img src="https://www.lydsy.com/JudgeOnline/images/1001.jpg" alt></p><p>数据范围：$n,m&lt;=1000$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>首先想到的是最大流 $=$ 最小割，可以跑一遍网络流。$TLE$。还有一个定理：平面图的最大流 $=$ 其对偶图的最短路。建对偶图，然后跑 $dijkstra+$ 堆优化。</p><h3 id="平面图"><a href="#平面图" class="headerlink" title="平面图"></a>平面图</h3><p>一边只在顶点处相交的图（其边不存在交叉）</p><h3 id="对偶图"><a href="#对偶图" class="headerlink" title="对偶图"></a>对偶图</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>对于每一个平面图， 都有与其相对应的对偶图。假设上面的例图是 $G$，与其对应的对偶图为 $G’$,那么对于 $G’$ 上面的每一个点， 对应的是 $G$ 里面的每一个面。</p><h4 id="构建方式"><a href="#构建方式" class="headerlink" title="构建方式"></a>构建方式</h4><p>如图。对于每条边，用一条 <strong>垂直与</strong> 它的边连接对应的两个点（面）</p><p><img src="https://i.loli.net/2019/08/14/uD3Wm7XHOhkVibs.png" alt></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M (n - 1) * (m - 1) * 2 + 1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000006</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> nxt, to,w;</span><br><span class="line">&#125; e[N * <span class="number">6</span> + <span class="number">106</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, dis;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (node x, node y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x.dis &gt; y.dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue &lt; node &gt; q;</span><br><span class="line"><span class="keyword">int</span> n, m, a, cnt = <span class="number">0</span>, dis[N * <span class="number">2</span> + <span class="number">106</span>], vis[N * <span class="number">2</span> + <span class="number">106</span>], head[N * <span class="number">2</span> + <span class="number">106</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(); <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123; <span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>; c = getchar(); &#125;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) &#123; x = x * <span class="number">10</span> + c - <span class="number">48</span>; c = getchar(); &#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++cnt] = (edge) &#123; head[x], y, w &#125;;</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">    e[++cnt] = (edge) &#123; head[y], x, w &#125;;</span><br><span class="line">    head[y] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    q.push((node) &#123; <span class="number">0</span>, <span class="number">0</span> &#125;);</span><br><span class="line">    dis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = q.top().id;</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(vis[a]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[a] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[a]; i; i = e[i].nxt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dis[v] &gt; dis[a] + e[i].w)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[a] + e[i].w;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v])</span><br><span class="line">                    q.push((node) &#123; v, dis[v] &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ID</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">1</span>) <span class="keyword">return</span> (x - <span class="number">1</span>) * (m - <span class="number">1</span>) * <span class="number">2</span> + y;</span><br><span class="line">    <span class="keyword">return</span> (x - <span class="number">1</span>) * (m - <span class="number">1</span>) * <span class="number">2</span> + y + m - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), m = read();</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span> || m == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; max(n, m); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a = read();</span><br><span class="line">            f = min(f, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, f);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            a = read();</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span>) add(ID(i, j, <span class="number">1</span>), <span class="number">0</span>, a);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == n) add(ID(i - <span class="number">1</span>, j, <span class="number">2</span>), M, a);</span><br><span class="line">            <span class="keyword">else</span> add(ID(i, j, <span class="number">1</span>), ID(i - <span class="number">1</span>, j, <span class="number">2</span>), a);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            a = read();</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">1</span>) add(ID(i, j, <span class="number">2</span>), M, a);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j == m) add(ID(i, j - <span class="number">1</span>, <span class="number">1</span>), <span class="number">0</span>, a);</span><br><span class="line">            <span class="keyword">else</span> add(ID(i, j, <span class="number">2</span>), ID(i, j - <span class="number">1</span>, <span class="number">1</span>), a);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            a = read();</span><br><span class="line">            add(ID(i, j, <span class="number">1</span>), ID(i, j, <span class="number">2</span>), a);</span><br><span class="line">        &#125;</span><br><span class="line">    dijkstra();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, dis[M]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;p&gt;给定一 $n*m$ 的网格图。每条边有一个流量，兔子从左上角 $(1,1)$ 跑到右下角 $(n,m)$。流量为 $k$ 的边需要 $k$ 匹狼才能堵住。&lt;/p&gt;
&lt;p&gt;求把兔子一网打尽所需的最少的狼。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https:LotusLeaves.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="对偶图" scheme="https:LotusLeaves.github.io/tags/%E5%AF%B9%E5%81%B6%E5%9B%BE/"/>
    
      <category term="平面图" scheme="https:LotusLeaves.github.io/tags/%E5%B9%B3%E9%9D%A2%E5%9B%BE/"/>
    
      <category term="网络流" scheme="https:LotusLeaves.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="最短路" scheme="https:LotusLeaves.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>洛谷 P2782 友好城市 题解</title>
    <link href="https:LotusLeaves.github.io/2019/07/24/%E6%B4%9B%E8%B0%B7%20P2782%20%E5%8F%8B%E5%A5%BD%E5%9F%8E%E5%B8%82%20%E9%A2%98%E8%A7%A3/"/>
    <id>https:LotusLeaves.github.io/2019/07/24/洛谷 P2782 友好城市 题解/</id>
    <published>2019-07-24T01:21:13.239Z</published>
    <updated>2019-08-15T00:21:01.815Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>一条河，南北岸各有 $n$ 座城市，每座城市有一个坐标。北岸的每座城市在南岸有一个“友好城市”，且不同城市的友好城市不同。如果在每对友好城市之间连边，在这些边互不相交的情况下使边数最多。</p><p>数据范围：$n&lt;=2e5, x_i&lt;=1e6$</p><a id="more"></a><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>$O(n^2)$ 的做法：先把南岸或者北岸排序，然后找另一边的最长不下降子序列。但是过不了这题。</p><p>$O(nlog_{n})$ 的做法：优化找最长不下降子序列的过程，使用 $upper$ _ $bound$ 函数找到第一个比当前大的数，替换它。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">city</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> s, n;</span><br><span class="line">&#125; a[N];</span><br><span class="line"><span class="keyword">int</span> n, len = <span class="number">0</span>, d[N];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(city a, city b)</span> </span>&#123; <span class="keyword">return</span> a.n &lt; b.n; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a[i].s, &amp;a[i].n);</span><br><span class="line">    sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp);</span><br><span class="line">    d[++len] = a[<span class="number">1</span>].s; <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> id = upper_bound(d + <span class="number">1</span>, d + len + <span class="number">1</span>, a[i].s) - d;</span><br><span class="line">        d[id] = a[i].s;</span><br><span class="line">        <span class="comment">//当前北岸编号较大，南岸编号较小，一定比刚才优</span></span><br><span class="line">        <span class="keyword">if</span>(id &gt; len) len++; <span class="comment">//如果新开了一个位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;p&gt;一条河，南北岸各有 $n$ 座城市，每座城市有一个坐标。北岸的每座城市在南岸有一个“友好城市”，且不同城市的友好城市不同。如果在每对友好城市之间连边，在这些边互不相交的情况下使边数最多。&lt;/p&gt;
&lt;p&gt;数据范围：$n&amp;lt;=2e5, x_i&amp;lt;=1e6$&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https:LotusLeaves.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="dp" scheme="https:LotusLeaves.github.io/tags/dp/"/>
    
      <category term="排序" scheme="https:LotusLeaves.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>JoyOI 中中的背包 题解</title>
    <link href="https:LotusLeaves.github.io/2019/07/23/JoyOI%20%E4%B8%AD%E4%B8%AD%E7%9A%84%E8%83%8C%E5%8C%85%20%E9%A2%98%E8%A7%A3/"/>
    <id>https:LotusLeaves.github.io/2019/07/23/JoyOI 中中的背包 题解/</id>
    <published>2019-07-23T11:52:04.363Z</published>
    <updated>2019-08-15T00:21:58.772Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>背包的容积为 $m$，$n$ 个物品，每样东西都有自己的价值、体积和个数（个数 $=0$ 表示无限多个）。求最大价值。</p><p>数据范围：$1&lt;=n,m&lt;=5500$</p><a id="more"></a><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>最暴力的做法是 $O(n^2m)$ 的，太慢了，怎么办？只要把每个物品都拆开，比如像 $z[i]=13$，我们把这个物品拆成 $1,2,4,6$，每个物品只能选 $1$ 次</p><p>具体的拆法是：先按照 $2$ 的次方来拆，直到当前$+2$的下一个次方数 $&gt;z[i]$ ，就按照 $z[i]−2$ 的当前次方数捆绑最后一堆物体</p><p>如上例，这 $4$ 个数可以凑出 $1–13$ 的所有数，所以跑一遍 $01$ 背包模板</p><p>为什么能凑出? 简单的证明：比如 $z[i]=31$ ，拆出来是 $1,2,4,8,10$，转化成二进制就是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">1</span></span><br><span class="line">    <span class="number">10</span></span><br><span class="line">   <span class="number">100</span></span><br><span class="line">  <span class="number">1000</span></span><br><span class="line"> <span class="number">10000</span></span><br><span class="line"><span class="number">100000</span></span><br></pre></td></tr></table></figure><p>如果右对齐一下，可以看到任意一位都有且仅有一个 $1$。把要凑的数转化成二进制，每一位有 $1$ 的话就加上这一位有 $1$ 的数。</p><p>这种情况是 $z[i]$ 正好能被 $2$ 的次方数凑出。如果不能，比如 $37$ ，最后一堆捆绑的物品就是 $6$。当选择 $1–31$ 个物品时，就按照上面的凑法；当选择 $32–37$ 个物品时，就先选择 $6$ 这一堆，然后再按照上面的凑法。</p><p>$upd:$ 似乎没有特判个数 $=0$ （无限多个）的情况，不过不影响 $AC$ …</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, cnt = <span class="number">0</span>, ans = <span class="number">0</span>, v[<span class="number">100000</span>], w[<span class="number">100000</span>], f[<span class="number">9001</span>];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c, x = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="keyword">while</span>(x &lt;= c)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            v[cnt] = a*x;</span><br><span class="line">            w[cnt] = b*x;</span><br><span class="line">            c -= x;</span><br><span class="line">            x *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            v[cnt] = a * c;</span><br><span class="line">            w[cnt] = b * c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    n = cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = m; j &gt;= v[i]; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            f[j] = max(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        ans = max(ans, f[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;p&gt;背包的容积为 $m$，$n$ 个物品，每样东西都有自己的价值、体积和个数（个数 $=0$ 表示无限多个）。求最大价值。&lt;/p&gt;
&lt;p&gt;数据范围：$1&amp;lt;=n,m&amp;lt;=5500$&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https:LotusLeaves.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="dp" scheme="https:LotusLeaves.github.io/tags/dp/"/>
    
      <category term="背包" scheme="https:LotusLeaves.github.io/tags/%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>洛谷 P2470 [SCOI2007]压缩 题解</title>
    <link href="https:LotusLeaves.github.io/2019/07/23/%E6%B4%9B%E8%B0%B7%20P2470%20%5BSCOI2007%5D%E5%8E%8B%E7%BC%A9%20%E9%A2%98%E8%A7%A3/"/>
    <id>https:LotusLeaves.github.io/2019/07/23/洛谷 P2470 [SCOI2007]压缩 题解/</id>
    <published>2019-07-23T10:32:59.021Z</published>
    <updated>2019-08-14T14:31:16.952Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>一个由小写字母组成的字符串，压缩其重复信息。压缩后的字符串除了小写字母外还可以（但不必）包含大写字母 $R$ 与 $M$，其中 $M$ 标记重复串的开始，$R$ 重复从上一个 $M$（如果当前位置左边没有 $M$，则从串的开始算起）开始的解压结果（称为缓冲串）。</p><a id="more"></a><p>串 $bcdcdcdcd$ 的解压过程：</p><p><img src="https://i.loli.net/2019/08/14/xKXdebmuTcgh2iN.png" alt></p><p>数据范围：$1&lt;=n&lt;=50$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>设 $f[i][j]$ 为当前处理到第 $i$ 个字符，上个 $M$ 放在了第 $j$ 个字符之后的最小长度。更新的时候使用刷表法。</p><p>有三种情况：</p><!--more--><p>$1.$ 什么也不做：$f[i+1][j]=min(f[i+1][j],f[i][j]+1)$</p><p>$2.$ 在后面放一个 $M$：$f[i][i]=min(f[i][i],f[i][j]+1)$</p><p>$3.$ 在后面放一个 $R$: $f[2i+j][j]=min(f[2i+j][j],f[i][j]+1)$</p><p>注意，这里需要判断一下区间 $(j,i]$ 和区间 $(i,i*2-j]$ 是不是完全相同。完全相同才能执行 $3.$这一步。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">60</span>][<span class="number">60</span>], n, ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> mid, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mid + len &gt; n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= len; k++)</span><br><span class="line">        <span class="keyword">if</span>(s[mid - len + k] != s[mid + k])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][i] = min(f[i][i],f[i][j] + <span class="number">1</span>);</span><br><span class="line">            f[i + <span class="number">1</span>][j] = min(f[i + <span class="number">1</span>][j],f[i][j] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(get(i, i - j))</span><br><span class="line">                f[i * <span class="number">2</span> - j][j] = min(f[i * <span class="number">2</span> - j][j], f[i][j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) ans = min(ans, f[n][i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;p&gt;一个由小写字母组成的字符串，压缩其重复信息。压缩后的字符串除了小写字母外还可以（但不必）包含大写字母 $R$ 与 $M$，其中 $M$ 标记重复串的开始，$R$ 重复从上一个 $M$（如果当前位置左边没有 $M$，则从串的开始算起）开始的解压结果（称为缓冲串）。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https:LotusLeaves.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="dp" scheme="https:LotusLeaves.github.io/tags/dp/"/>
    
      <category term="字符串" scheme="https:LotusLeaves.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>JoyOI 数字三角形2 题解</title>
    <link href="https:LotusLeaves.github.io/2019/07/23/JoyOI%20%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A22%20%E9%A2%98%E8%A7%A3/"/>
    <id>https:LotusLeaves.github.io/2019/07/23/JoyOI 数字三角形2 题解/</id>
    <published>2019-07-23T05:08:43.793Z</published>
    <updated>2019-08-15T00:22:36.905Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>给定数字三角形，要求最后答案 $mod$ $100$ 最大。</p><p>数据范围：$n&lt;=25$</p><a id="more"></a><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>设 $bool$ $f[i][j][k]$ 为走到 $(i,j)$ 这个点 $mod$ $100$ 能不能得到 $k$。更新使用刷表法。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, f[<span class="number">100</span>][<span class="number">100</span>][<span class="number">150</span>], a[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]);</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>][a[<span class="number">1</span>][<span class="number">1</span>] % <span class="number">100</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">100</span>; k++)</span><br><span class="line">                <span class="keyword">if</span>(f[i][j][k])</span><br><span class="line">                &#123;</span><br><span class="line">                    f[i + <span class="number">1</span>][j][(k + a[i + <span class="number">1</span>][j]) % <span class="number">100</span>] = <span class="number">1</span>;</span><br><span class="line">                    f[i + <span class="number">1</span>][j + <span class="number">1</span>][(k + a[i + <span class="number">1</span>][j + <span class="number">1</span>]) % <span class="number">100</span>] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">100</span>; k++)</span><br><span class="line">            <span class="keyword">if</span>(f[n][i][k]) ans = max(ans, k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;p&gt;给定数字三角形，要求最后答案 $mod$ $100$ 最大。&lt;/p&gt;
&lt;p&gt;数据范围：$n&amp;lt;=25$&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https:LotusLeaves.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="dp" scheme="https:LotusLeaves.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>洛谷 P4302 [SCOI2003]字符串折叠 题解</title>
    <link href="https:LotusLeaves.github.io/2019/07/23/%E6%B4%9B%E8%B0%B7%20P4302%20%5BSCOI2003%5D%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8A%98%E5%8F%A0%20%E9%A2%98%E8%A7%A3/"/>
    <id>https:LotusLeaves.github.io/2019/07/23/洛谷 P4302 [SCOI2003]字符串折叠 题解/</id>
    <published>2019-07-23T04:46:33.771Z</published>
    <updated>2019-08-15T00:22:57.913Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>折叠的定义如下：</p><p>$1.$ 一个字符串可以看成它自身的折叠。记作 $S=S$.</p><p>$2.$ $X(S)$ 是 $X(X&gt;1)$ 个 $S$ 连接在一起的串的折叠。记作 $X(S)=SSSS…S$ ( $X$ 个 $S$ )。</p><a id="more"></a><p>如果 $A=A’$, $B=B’$，则 $AB=A’B’$ 例如，因为 $3(A)=AAA$, $2(B)=BB$，所以 $3(A)C2(B)=AAACBB$，而 $2(3(A)C)2(B)=AAACAAACBB$</p><p>求给定字符串的最短折叠。</p><p>数据范围：$len&lt;=100$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>设 $f[i][j]$ 为表示区间 $[i,j]$ 折叠的最小长度。 $get(i,j,k,h)$ 表示区间 $[i,j]$ 和区间 $[k,h]$ 能否折叠。</p><p>如果能够折叠：$f[i][j]=min(f[i][j],f[i][k]+2+cal((j-i+1)/(k-i+1)))$ （其中 $cal(x)$ 返回的是 $x$ 的位数）</p><p>否则：$f[i][j]=min(f[i][j],f[i][k]+f[k+1][j])$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300</span>;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">int</span> f[N][N], n;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((y2 - x1 + <span class="number">1</span>) % (y1 - x1 + <span class="number">1</span>) != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> len = y1 - x1 + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x2; i &lt;= y2; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] != s[i - len])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(k)</span><br><span class="line">    &#123;</span><br><span class="line">        k /= <span class="number">10</span>;</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    n = s.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) f[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l + i &lt; n; l++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> r = l + i;</span><br><span class="line">            f[l][r] = r - l + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = l; k &lt; r; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!get(l, k, k + <span class="number">1</span>, r))</span><br><span class="line">                    f[l][r] = min(f[l][r], f[l][k] + f[k + <span class="number">1</span>][r]);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f[l][r] = min(f[l][r], f[l][k] + <span class="number">2</span> + cal((r - l + <span class="number">1</span>) / (k - l + <span class="number">1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, f[<span class="number">0</span>][n - <span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;p&gt;折叠的定义如下：&lt;/p&gt;
&lt;p&gt;$1.$ 一个字符串可以看成它自身的折叠。记作 $S=S$.&lt;/p&gt;
&lt;p&gt;$2.$ $X(S)$ 是 $X(X&amp;gt;1)$ 个 $S$ 连接在一起的串的折叠。记作 $X(S)=SSSS…S$ ( $X$ 个 $S$ )。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https:LotusLeaves.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="dp" scheme="https:LotusLeaves.github.io/tags/dp/"/>
    
      <category term="区间dp" scheme="https:LotusLeaves.github.io/tags/%E5%8C%BA%E9%97%B4dp/"/>
    
  </entry>
  
  <entry>
    <title>洛谷 P4766 [CERC2014]Outer space invaders 题解</title>
    <link href="https:LotusLeaves.github.io/2019/07/23/%E6%B4%9B%E8%B0%B7%20P4766%20%5BCERC2014%5DOuter%20space%20invaders%20%E9%A2%98%E8%A7%A3/"/>
    <id>https:LotusLeaves.github.io/2019/07/23/洛谷 P4766 [CERC2014]Outer space invaders 题解/</id>
    <published>2019-07-23T01:06:00.932Z</published>
    <updated>2019-08-14T14:45:49.122Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>有 $n$ 个外星人进攻，第 $i$ 个外星出现时间为 $a_i$ ，距离为 $d_i$ ,必须在时间 $b_i$ 前被消灭。</p><p>你的武器可以设置任何给定的功率。如果被设置了功率 $R$，它会摧毁距离在 $R$ 及以内的所有外星人，同时消耗 $R$ 单位的燃料。</p><a id="more"></a><p>求存活条件下最少要消耗多少燃料。</p><p>数据范围：$n&lt;=300 , 1&lt;=a_i&lt;b_i&lt;=10000 , 1&lt;=d_i&lt;=10000$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>设 $f[i][j]$ 为消灭 $i–j$ 时间内外星人的最少花费。设这段区间最晚出现的外星人编号为 $id$，则转移方程为：</p><p>$f[i][j]=min(f[i][j],f[i][k-1]+a[id].d+f[k+1][j])$</p><p>如果开二维数组，$10000$ 有点太大。题面只出现了 $300$ 个外星人，可以离散化。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">50005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, d;</span><br><span class="line">&#125; a[maxn];</span><br><span class="line"><span class="keyword">int</span> T, n, m, t[maxn], cnt, f[<span class="number">700</span>][<span class="number">700</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a[i].l, &amp;a[i].r, &amp;a[i].d);</span><br><span class="line">        t[++cnt] = a[i].l;</span><br><span class="line">        t[++cnt] = a[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(t + <span class="number">1</span>, t + cnt + <span class="number">1</span>);</span><br><span class="line">    m = unique(t + <span class="number">1</span>, t + cnt + <span class="number">1</span>) - t - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i].l = lower_bound(t + <span class="number">1</span>, t + m + <span class="number">1</span>, a[i].l) - t;</span><br><span class="line">        a[i].r = lower_bound(t + <span class="number">1</span>, t + m + <span class="number">1</span>, a[i].r) - t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>; l + i &lt;= m; l++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> r = l + i, id = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                <span class="keyword">if</span>(a[j].l &gt;= l &amp;&amp; a[j].r &lt;= r &amp;&amp; (!id || a[j].d &gt; a[id].d))</span><br><span class="line">                    id = j;</span><br><span class="line">            <span class="keyword">if</span>(!id) &#123; f[l][r] = <span class="number">0</span>; <span class="keyword">continue</span>; &#125;</span><br><span class="line">            f[l][r] = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = a[id].l; k &lt;= a[id].r; k++)</span><br><span class="line">                f[l][r] = min(f[l][r], f[l][k - <span class="number">1</span>] + f[k + <span class="number">1</span>][r] + a[id].d);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[<span class="number">1</span>][m]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h2&gt;&lt;p&gt;有 $n$ 个外星人进攻，第 $i$ 个外星出现时间为 $a_i$ ，距离为 $d_i$ ,必须在时间 $b_i$ 前被消灭。&lt;/p&gt;
&lt;p&gt;你的武器可以设置任何给定的功率。如果被设置了功率 $R$，它会摧毁距离在 $R$ 及以内的所有外星人，同时消耗 $R$ 单位的燃料。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https:LotusLeaves.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="dp" scheme="https:LotusLeaves.github.io/tags/dp/"/>
    
      <category term="区间dp" scheme="https:LotusLeaves.github.io/tags/%E5%8C%BA%E9%97%B4dp/"/>
    
      <category term="离散化" scheme="https:LotusLeaves.github.io/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>离散化</title>
    <link href="https:LotusLeaves.github.io/2019/07/23/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    <id>https:LotusLeaves.github.io/2019/07/23/离散化/</id>
    <published>2019-07-22T23:59:02.659Z</published>
    <updated>2019-08-15T00:16:49.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>离散化</strong>，把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。也就是说，我们不关心数据的真实大小，只关心数据的 <strong>相对</strong> 大小。比如我们要把 $1e5$ 个范围是 $1e9$ 的数进行并查集。</p><a id="more"></a><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000005</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a[N], t[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">t[i] = a[i];</span><br><span class="line">&#125;</span><br><span class="line">sort(t + <span class="number">1</span>, t + n + <span class="number">1</span>);</span><br><span class="line">m = unique(t + <span class="number">1</span>, t + n + <span class="number">1</span>) - t - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">a[i] = lower_bound(t + <span class="number">1</span>, t + m + <span class="number">1</span>, a[i]) - t;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 $unique$ 返回的是去重后的 <strong>尾地址</strong> ，需要减去首地址才能使用。$lower$_$bound$ 返回的是左闭右开区间 $[first,last)$ 中第一个大于等于 $val$ 的元素地址（也就是说 $last$ 是越界的）</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;离散化&lt;/strong&gt;，把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。也就是说，我们不关心数据的真实大小，只关心数据的 &lt;strong&gt;相对&lt;/strong&gt; 大小。比如我们要把 $1e5$ 个范围是 $1e9$ 的数进行并查集。&lt;/p&gt;
    
    </summary>
    
      <category term="笔记" scheme="https:LotusLeaves.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="离散化" scheme="https:LotusLeaves.github.io/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    
  </entry>
  
</feed>
