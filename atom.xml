<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lxy&#39;s blog</title>
  
  <subtitle>Achieve my dream ...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https:LotusLeaves.github.io/"/>
  <updated>2019-07-31T08:37:51.166Z</updated>
  <id>https:LotusLeaves.github.io/</id>
  
  <author>
    <name>lxy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>贝多芬计划</title>
    <link href="https:LotusLeaves.github.io/2019/07/31/%E8%B4%9D%E5%A4%9A%E8%8A%AC%E8%AE%A1%E5%88%92/"/>
    <id>https:LotusLeaves.github.io/2019/07/31/贝多芬计划/</id>
    <published>2019-07-31T08:35:00.308Z</published>
    <updated>2019-07-31T08:37:51.166Z</updated>
    
    <content type="html"><![CDATA[<h3 id="反正就是背代码…"><a href="#反正就是背代码…" class="headerlink" title="反正就是背代码…"></a>反正就是背代码…</h3><p><a href="https://www.luogu.org/record/21862899" target="_blank" rel="noopener">高精四位压缩（部分）</a></p><p><a href="https://www.luogu.org/record/21889405" target="_blank" rel="noopener">treap模板</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;反正就是背代码…&quot;&gt;&lt;a href=&quot;#反正就是背代码…&quot; class=&quot;headerlink&quot; title=&quot;反正就是背代码…&quot;&gt;&lt;/a&gt;反正就是背代码…&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/record/21862899
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="https:LotusLeaves.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="背代码" scheme="https:LotusLeaves.github.io/tags/%E8%83%8C%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>bzoj 1001 [BeiJing2006]狼抓兔子 题解</title>
    <link href="https:LotusLeaves.github.io/2019/07/26/bzoj%201001%20%5BBeiJing2006%5D%E7%8B%BC%E6%8A%93%E5%85%94%E5%AD%90%20%E9%A2%98%E8%A7%A3/"/>
    <id>https:LotusLeaves.github.io/2019/07/26/bzoj 1001 [BeiJing2006]狼抓兔子 题解/</id>
    <published>2019-07-26T01:40:02.943Z</published>
    <updated>2019-08-13T13:59:34.157Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1001" target="_blank" rel="noopener">题目链接</a></p><p>首先想到的是最大流=最小割，可以跑一遍网络流。TLE。还有一个定理：平面图的最大流=其对偶图的最短路。</p><p>建对偶图，然后跑dijkstra+堆优化即可。</p><a id="more"></a><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M (n - 1) * (m - 1) * 2 + 1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000006</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> nxt, to,w;</span><br><span class="line">&#125; e[N * <span class="number">6</span> + <span class="number">106</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id, dis;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (node x, node y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x.dis &gt; y.dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue &lt; node &gt; q;</span><br><span class="line"><span class="keyword">int</span> n, m, a, cnt = <span class="number">0</span>, dis[N * <span class="number">2</span> + <span class="number">106</span>], vis[N * <span class="number">2</span> + <span class="number">106</span>], head[N * <span class="number">2</span> + <span class="number">106</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = getchar(); <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) &#123; <span class="keyword">if</span>(c == <span class="string">'-'</span>) f = <span class="number">-1</span>; c = getchar(); &#125;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) &#123; x = x * <span class="number">10</span> + c - <span class="number">48</span>; c = getchar(); &#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++cnt] = (edge) &#123; head[x], y, w &#125;;</span><br><span class="line">    head[x] = cnt;</span><br><span class="line">    e[++cnt] = (edge) &#123; head[y], x, w &#125;;</span><br><span class="line">    head[y] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    q.push((node) &#123; <span class="number">0</span>, <span class="number">0</span> &#125;);</span><br><span class="line">    dis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = q.top().id;</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(vis[a]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[a] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = head[a]; i; i = e[i].nxt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(dis[v] &gt; dis[a] + e[i].w)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[a] + e[i].w;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v])</span><br><span class="line">                    q.push((node) &#123; v, dis[v] &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ID</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">1</span>) <span class="keyword">return</span> (x - <span class="number">1</span>) * (m - <span class="number">1</span>) * <span class="number">2</span> + y;</span><br><span class="line">    <span class="keyword">return</span> (x - <span class="number">1</span>) * (m - <span class="number">1</span>) * <span class="number">2</span> + y + m - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n = read(), m = read();</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span> || m == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; max(n, m); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a = read();</span><br><span class="line">            f = min(f, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, f);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            a = read();</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">1</span>) add(ID(i, j, <span class="number">1</span>), <span class="number">0</span>, a);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == n) add(ID(i - <span class="number">1</span>, j, <span class="number">2</span>), M, a);</span><br><span class="line">            <span class="keyword">else</span> add(ID(i, j, <span class="number">1</span>), ID(i - <span class="number">1</span>, j, <span class="number">2</span>), a);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            a = read();</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">1</span>) add(ID(i, j, <span class="number">2</span>), M, a);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j == m) add(ID(i, j - <span class="number">1</span>, <span class="number">1</span>), <span class="number">0</span>, a);</span><br><span class="line">            <span class="keyword">else</span> add(ID(i, j, <span class="number">2</span>), ID(i, j - <span class="number">1</span>, <span class="number">1</span>), a);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            a = read();</span><br><span class="line">            add(ID(i, j, <span class="number">1</span>), ID(i, j, <span class="number">2</span>), a);</span><br><span class="line">        &#125;</span><br><span class="line">    dijkstra();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, dis[M]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=1001&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先想到的是最大流=最小割，可以跑一遍网络流。TLE。还有一个定理：平面图的最大流=其对偶图的最短路。&lt;/p&gt;
&lt;p&gt;建对偶图，然后跑dijkstra+堆优化即可。&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https:LotusLeaves.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="对偶图" scheme="https:LotusLeaves.github.io/tags/%E5%AF%B9%E5%81%B6%E5%9B%BE/"/>
    
      <category term="平面图" scheme="https:LotusLeaves.github.io/tags/%E5%B9%B3%E9%9D%A2%E5%9B%BE/"/>
    
      <category term="网络流" scheme="https:LotusLeaves.github.io/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>洛谷 P2782 友好城市 题解</title>
    <link href="https:LotusLeaves.github.io/2019/07/24/%E6%B4%9B%E8%B0%B7%20P2782%20%E5%8F%8B%E5%A5%BD%E5%9F%8E%E5%B8%82%20%E9%A2%98%E8%A7%A3/"/>
    <id>https:LotusLeaves.github.io/2019/07/24/洛谷 P2782 友好城市 题解/</id>
    <published>2019-07-24T01:21:13.239Z</published>
    <updated>2019-08-13T06:54:28.792Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2782" target="_blank" rel="noopener">题目链接</a></p><p><code>O(n^2)</code>的做法：先把南岸或者北岸排序，然后找另一边的最长不下降子序列。但是过不了这题。</p><p><code>O(nlogn)</code>的做法：优化找最长不下降子序列的过程，使用<code>upper_bound</code>函数找到第一个比当前大的数，替换它。</p><a id="more"></a><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">300005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">city</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> s,n;</span><br><span class="line">&#125;a[maxn];</span><br><span class="line"><span class="keyword">int</span> n,len=<span class="number">0</span>,d[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(city a,city b)</span> </span>&#123; <span class="keyword">return</span> a.n&lt;b.n; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a[i].s,&amp;a[i].n);</span><br><span class="line">    sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>,cmp);</span><br><span class="line">    d[++len]=a[<span class="number">1</span>].s; <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> id=upper_bound(d+<span class="number">1</span>,d+len+<span class="number">1</span>,a[i].s)-d;</span><br><span class="line">        d[id]=a[i].s;</span><br><span class="line">        <span class="comment">//当前北岸编号较大，南岸编号较小，一定比刚才优</span></span><br><span class="line">        <span class="keyword">if</span>(id&gt;len) len++; <span class="comment">//如果新开了一个位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P2782&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;O(n^2)&lt;/code&gt;的做法：先把南岸或者北岸排序，然后找另一边的最长不下降子序列。但是过不了这题。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;O(nlogn)&lt;/code&gt;的做法：优化找最长不下降子序列的过程，使用&lt;code&gt;upper_bound&lt;/code&gt;函数找到第一个比当前大的数，替换它。&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https:LotusLeaves.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="dp" scheme="https:LotusLeaves.github.io/tags/dp/"/>
    
      <category term="排序" scheme="https:LotusLeaves.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>JoyOI 中中的背包 题解</title>
    <link href="https:LotusLeaves.github.io/2019/07/23/JoyOI%20%E4%B8%AD%E4%B8%AD%E7%9A%84%E8%83%8C%E5%8C%85%20%E9%A2%98%E8%A7%A3/"/>
    <id>https:LotusLeaves.github.io/2019/07/23/JoyOI 中中的背包 题解/</id>
    <published>2019-07-23T11:52:04.363Z</published>
    <updated>2019-08-13T08:24:02.503Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.joyoi.cn/problem/tyvj-1662" target="_blank" rel="noopener">题目链接</a></p><p>最暴力的做法是<code>O(n^2m)</code>的，太慢了，怎么办？</p><p>只要把每个物品都拆开，比如像 <code>z[i]=13</code></p><a id="more"></a><p>我们把这个物品拆成<code>1,2,4,6</code>，每个物品只能选<code>1</code>次</p><p>具体的拆法是：先按照 22 的次方来拆，直到当前和 <code>+</code>【 <code>2</code> 的下一个次方数】 <code>&gt;z[i]</code> ，就按照【 <code>z[i]−2</code> 的当前次方数】捆绑最后一堆物体</p><p>这<code>4</code>个数可以凑出<code>1−13</code>的所有数，所以跑一遍<code>01</code>背包模板</p><p>为什么能凑出？简单的证明：</p><p>比如<code>z[i]=31</code>，拆出来是<code>1,2,4,8,16</code></p><p>转化成二进制就是：</p><p><code>1</code></p><p><code>10</code></p><p><code>100</code></p><p><code>1000</code></p><p><code>10000</code></p><p><code>100000</code></p><p>如果右对齐一下的话可以看到任意一位都有且仅有一个<code>1</code>。把要凑的数转化成二进制，每一位有<code>1</code>的话就加上这一位有<code>1</code>的数。</p><p>那么这种情况是正好能用<code>22</code>的次方数凑出的。如果不能，比如 3737 ，最后一堆捆绑的物品就是<code>6</code>。当选择<code>1-31个</code>物品时，就按照上面的凑法；当选择<code>32-37</code>个物品时，就先选择<code>6</code>这一堆，然后再按照上面的凑法。</p><p>这样要被凑的数就一定可以通过相加得出。</p><p>代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,cnt=<span class="number">0</span>,ans=<span class="number">0</span>,v[<span class="number">100000</span>],w[<span class="number">100000</span>],f[<span class="number">9001</span>];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,c,x=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="keyword">while</span>(x&lt;=c)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            v[cnt]=a*x;</span><br><span class="line">            w[cnt]=b*x;</span><br><span class="line">            c-=x;</span><br><span class="line">            x*=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            v[cnt]=a*c;</span><br><span class="line">            w[cnt]=b*c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    n=cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=m;j&gt;=v[i];j--)</span><br><span class="line">        &#123;</span><br><span class="line">            f[j]=max(f[j],f[j-v[i]]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        ans=max(ans,f[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.joyoi.cn/problem/tyvj-1662&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最暴力的做法是&lt;code&gt;O(n^2m)&lt;/code&gt;的，太慢了，怎么办？&lt;/p&gt;
&lt;p&gt;只要把每个物品都拆开，比如像 &lt;code&gt;z[i]=13&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https:LotusLeaves.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="dp" scheme="https:LotusLeaves.github.io/tags/dp/"/>
    
      <category term="背包" scheme="https:LotusLeaves.github.io/tags/%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>洛谷 P2470 [SCOI2007]压缩 题解</title>
    <link href="https:LotusLeaves.github.io/2019/07/23/%E6%B4%9B%E8%B0%B7%20P2470%20%5BSCOI2007%5D%E5%8E%8B%E7%BC%A9%20%E9%A2%98%E8%A7%A3/"/>
    <id>https:LotusLeaves.github.io/2019/07/23/洛谷 P2470 [SCOI2007]压缩 题解/</id>
    <published>2019-07-23T10:32:59.021Z</published>
    <updated>2019-07-23T11:49:22.261Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2470" target="_blank" rel="noopener">题目链接</a></p><p>设<code>f[i][j]</code>为当前处理到第<code>i</code>个字符，上个<code>M</code>放在了第<code>j</code>个字符之后的最小长度。更新的时候使用刷表法。</p><p>有三种情况：</p><a id="more"></a><p>1.什么也不做：<code>f[i+1][j]=min(f[i+1][j],f[i][j]+1)</code></p><p>2.在后面放一个<code>M</code>：<code>f[i][i]=min(f[i][i],f[i][j]+1)</code></p><p>3.在后面放一个<code>R</code>: <code>f[i*2+j][j]=min(f[i*2+j][j],f[i][j]+1)</code></p><p>注意，这里需要判断一下区间<code>(j,i]</code>和区间<code>(i,i*2-j]</code>是不是完全相同。完全相同才能执行<code>3.</code>这一步。</p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char s[100];</span><br><span class="line">int f[60][60],n,ans=0x3f3f3f3f;</span><br><span class="line">bool get(int mid,int len)</span><br><span class="line">&#123;</span><br><span class="line">    if(mid+len&gt;n) return false;</span><br><span class="line">    for(int k=1;k&lt;=len;k++)</span><br><span class="line">        if(s[mid-len+k]!=s[mid+k])</span><br><span class="line">            return false;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%s&quot;,s+1);</span><br><span class="line">    memset(f,0x3f,sizeof(f));</span><br><span class="line">    n=strlen(s+1);</span><br><span class="line">    f[0][0]=0;</span><br><span class="line">    for(int i=0;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j=0;j&lt;=i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][i]=min(f[i][i],f[i][j]+1);</span><br><span class="line">            f[i+1][j]=min(f[i+1][j],f[i][j]+1);</span><br><span class="line">            if(get(i,i-j))</span><br><span class="line">                f[i*2-j][j]=min(f[i*2-j][j],f[i][j]+1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;=n;i++)</span><br><span class="line">        ans=min(ans,f[n][i]);</span><br><span class="line">    printf(&quot;%d&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P2470&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;设&lt;code&gt;f[i][j]&lt;/code&gt;为当前处理到第&lt;code&gt;i&lt;/code&gt;个字符，上个&lt;code&gt;M&lt;/code&gt;放在了第&lt;code&gt;j&lt;/code&gt;个字符之后的最小长度。更新的时候使用刷表法。&lt;/p&gt;
&lt;p&gt;有三种情况：&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https:LotusLeaves.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="dp" scheme="https:LotusLeaves.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>JoyOI 数字三角形2 题解</title>
    <link href="https:LotusLeaves.github.io/2019/07/23/JoyOI%20%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A22%20%E9%A2%98%E8%A7%A3/"/>
    <id>https:LotusLeaves.github.io/2019/07/23/JoyOI 数字三角形2 题解/</id>
    <published>2019-07-23T05:08:43.793Z</published>
    <updated>2019-08-13T08:24:18.302Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.joyoi.cn/problem/tyvj-1076" target="_blank" rel="noopener">题目链接</a></p><p>题目要求结果<code>mod 100</code>最大，一般的<code>dp</code>肯定不行。可以设<code>bool f[i][j][k]</code>为走到<code>(i,j)</code>这个点<code>mod 100</code>能不能得到<code>k</code></p><p>可以用自己更新别人。</p><a id="more"></a><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,f[<span class="number">100</span>][<span class="number">100</span>][<span class="number">150</span>],a[<span class="number">50</span>][<span class="number">50</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i][j]);</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>][a[<span class="number">1</span>][<span class="number">1</span>]%<span class="number">100</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">100</span>;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(f[i][j][k])</span><br><span class="line">                &#123;</span><br><span class="line">                    f[i+<span class="number">1</span>][j][(k+a[i+<span class="number">1</span>][j])%<span class="number">100</span>]=<span class="number">1</span>;</span><br><span class="line">                    f[i+<span class="number">1</span>][j+<span class="number">1</span>][(k+a[i+<span class="number">1</span>][j+<span class="number">1</span>])%<span class="number">100</span>]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">-0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">100</span>;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[n][i][k])</span><br><span class="line">                ans=max(ans,k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://www.joyoi.cn/problem/tyvj-1076&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题目要求结果&lt;code&gt;mod 100&lt;/code&gt;最大，一般的&lt;code&gt;dp&lt;/code&gt;肯定不行。可以设&lt;code&gt;bool f[i][j][k]&lt;/code&gt;为走到&lt;code&gt;(i,j)&lt;/code&gt;这个点&lt;code&gt;mod 100&lt;/code&gt;能不能得到&lt;code&gt;k&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;可以用自己更新别人。&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https:LotusLeaves.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="dp" scheme="https:LotusLeaves.github.io/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>洛谷 P4302 [SCOI2003]字符串折叠 题解</title>
    <link href="https:LotusLeaves.github.io/2019/07/23/%E6%B4%9B%E8%B0%B7%20P4302%20%5BSCOI2003%5D%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8A%98%E5%8F%A0%20%E9%A2%98%E8%A7%A3/"/>
    <id>https:LotusLeaves.github.io/2019/07/23/洛谷 P4302 [SCOI2003]字符串折叠 题解/</id>
    <published>2019-07-23T04:46:33.771Z</published>
    <updated>2019-07-23T05:15:12.763Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4302" target="_blank" rel="noopener">题目链接</a></p><p>设<code>f[i][j]</code>为表示区间<code>[i,j]</code>的最小长度。<code>get(i,j,k,h)</code>表示区间<code>[i,j]</code>和区间<code>[k,h]</code>能否折叠。</p><p>如果能够折叠：<code>f[i][j]=min(f[i][j],f[i][k]+2+cal((j-i+1)/(k-i+1)))</code> （其中<code>cal(x)</code>返回的是<code>x</code>的位数）</p><a id="more"></a><p>否则：<code>f[i][j]=min(f[i][j],f[i][k]+f[k+1][j])</code></p><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=300;</span><br><span class="line">string s;</span><br><span class="line">int f[maxn][maxn],n;</span><br><span class="line">bool get(int x1,int y1,int x2,int y2)</span><br><span class="line">&#123;</span><br><span class="line">    if((y2-x1+1)%(y1-x1+1)!=0) return false;</span><br><span class="line">    int len=y1-x1+1;</span><br><span class="line">    for(int i=x2;i&lt;=y2;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(s[i]!=s[i-len])</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line">int cal(int k)</span><br><span class="line">&#123;</span><br><span class="line">    int ans=0;</span><br><span class="line">    while(k)</span><br><span class="line">    &#123;</span><br><span class="line">        k/=10;</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">    n=s.size();</span><br><span class="line">    for(int i=0;i&lt;n;i++) f[i][i]=1;</span><br><span class="line">    for(int i=1;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int l=0;l+i&lt;n;l++)</span><br><span class="line">        &#123;</span><br><span class="line">            int r=l+i;</span><br><span class="line">            f[l][r]=r-l+1;</span><br><span class="line">            for(int k=l;k&lt;r;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(!get(l,k,k+1,r))</span><br><span class="line">                    f[l][r]=min(f[l][r],f[l][k]+f[k+1][r]);</span><br><span class="line">                else</span><br><span class="line">                    f[l][r]=min(f[l][r],f[l][k]+2+cal((r-l+1)/(k-l+1)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,f[0][n-1]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P4302&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;设&lt;code&gt;f[i][j]&lt;/code&gt;为表示区间&lt;code&gt;[i,j]&lt;/code&gt;的最小长度。&lt;code&gt;get(i,j,k,h)&lt;/code&gt;表示区间&lt;code&gt;[i,j]&lt;/code&gt;和区间&lt;code&gt;[k,h]&lt;/code&gt;能否折叠。&lt;/p&gt;
&lt;p&gt;如果能够折叠：&lt;code&gt;f[i][j]=min(f[i][j],f[i][k]+2+cal((j-i+1)/(k-i+1)))&lt;/code&gt; （其中&lt;code&gt;cal(x)&lt;/code&gt;返回的是&lt;code&gt;x&lt;/code&gt;的位数）&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="https:LotusLeaves.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="dp" scheme="https:LotusLeaves.github.io/tags/dp/"/>
    
      <category term="区间dp" scheme="https:LotusLeaves.github.io/tags/%E5%8C%BA%E9%97%B4dp/"/>
    
  </entry>
  
  <entry>
    <title>洛谷 P4766 [CERC2014]Outer space invaders 题解</title>
    <link href="https:LotusLeaves.github.io/2019/07/23/%E6%B4%9B%E8%B0%B7%20P4766%20%5BCERC2014%5DOuter%20space%20invaders%20%E9%A2%98%E8%A7%A3/"/>
    <id>https:LotusLeaves.github.io/2019/07/23/洛谷 P4766 [CERC2014]Outer space invaders 题解/</id>
    <published>2019-07-23T01:06:00.932Z</published>
    <updated>2019-08-13T09:53:01.438Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4766" target="_blank" rel="noopener">题目链接</a></p><p>设<code>f[i][j]</code>为消灭 <code>i</code>，<code>j</code> 时间内外星人的最少花费。设这段区间最晚出现的外星人编号为<code>id</code>，则转移方程为：</p><p><code>f[i][j]=min(f[i][j],f[i][k-1]+a[id].d+f[k+1][j])</code></p><a id="more"></a><p>如果开二维数组，<code>10000</code> 有点太大。但是题面只出现了 <code>300</code> 个外星人，所以需要离散化。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">50005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,d;</span><br><span class="line">&#125; a[maxn];</span><br><span class="line"><span class="keyword">int</span> T,n,m,t[maxn],cnt,f[<span class="number">700</span>][<span class="number">700</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a[i].l,&amp;a[i].r,&amp;a[i].d);</span><br><span class="line">        t[++cnt]=a[i].l;</span><br><span class="line">        t[++cnt]=a[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(t+<span class="number">1</span>,t+cnt+<span class="number">1</span>);</span><br><span class="line">    m=unique(t+<span class="number">1</span>,t+cnt+<span class="number">1</span>)-t<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i].l=lower_bound(t+<span class="number">1</span>,t+m+<span class="number">1</span>,a[i].l)-t;</span><br><span class="line">        a[i].r=lower_bound(t+<span class="number">1</span>,t+m+<span class="number">1</span>,a[i].r)-t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">1</span>;l+i&lt;=m;l++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> r=l+i,id=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                <span class="keyword">if</span>(a[j].l&gt;=l&amp;&amp;a[j].r&lt;=r&amp;&amp;(!id||a[j].d&gt;a[id].d))</span><br><span class="line">                    id=j;</span><br><span class="line">            <span class="keyword">if</span>(!id) &#123; f[l][r]=<span class="number">0</span>; <span class="keyword">continue</span>; &#125;</span><br><span class="line">            f[l][r]=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=a[id].l;k&lt;=a[id].r;k++)</span><br><span class="line">                f[l][r]=min(f[l][r],f[l][k<span class="number">-1</span>]+f[k+<span class="number">1</span>][r]+a[id].d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f[<span class="number">1</span>][m]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P4766&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;设&lt;code&gt;f[i][j]&lt;/code&gt;为消灭 &lt;code&gt;i&lt;/code&gt;，&lt;code&gt;j&lt;/code&gt; 时间内外星人的最少花费。设这段区间最晚出现的外星人编号为&lt;code&gt;id&lt;/code&gt;，则转移方程为：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;f[i][j]=min(f[i][j],f[i][k-1]+a[id].d+f[k+1][j])&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https:LotusLeaves.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="题解" scheme="https:LotusLeaves.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="dp" scheme="https:LotusLeaves.github.io/tags/dp/"/>
    
      <category term="区间dp" scheme="https:LotusLeaves.github.io/tags/%E5%8C%BA%E9%97%B4dp/"/>
    
      <category term="离散化" scheme="https:LotusLeaves.github.io/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>离散化</title>
    <link href="https:LotusLeaves.github.io/2019/07/23/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    <id>https:LotusLeaves.github.io/2019/07/23/离散化/</id>
    <published>2019-07-22T23:59:02.659Z</published>
    <updated>2019-07-23T00:17:06.959Z</updated>
    
    <content type="html"><![CDATA[<p><strong>离散化</strong>，把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。也就是说，我们不关心数据的真实大小，只关心数据的 <strong>相对</strong> 大小。比如我们要把<code>1e5</code>个范围是<code>1e9</code>的数进行并查集。</p><a id="more"></a><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1000005;</span><br><span class="line">int n,m,a[N],t[N];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">scanf(&quot;%d%d&quot;,&amp;n,&amp;m);</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">  scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">  t[i]=a[i];</span><br><span class="line">&#125;</span><br><span class="line">sort(t+1,t+n+1);</span><br><span class="line">m=unique(t+1,t+n+1)-t-1;</span><br><span class="line">for(int i=1;i&lt;=n;i++)</span><br><span class="line">  a[i]=lower_bound(t+1,t+m+1,a[i])-t;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>unique</code>返回的是去重后的 <strong>尾地址</strong> ，需要减去首地址才能使用。<code>lower_bound</code>返回的是左闭右开区间<code>[first,last)</code>中第一个大于等于<code>val</code>的元素地址（也就是说<code>last</code>是越界的）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;离散化&lt;/strong&gt;，把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。也就是说，我们不关心数据的真实大小，只关心数据的 &lt;strong&gt;相对&lt;/strong&gt; 大小。比如我们要把&lt;code&gt;1e5&lt;/code&gt;个范围是&lt;code&gt;1e9&lt;/code&gt;的数进行并查集。&lt;/p&gt;
    
    </summary>
    
    
      <category term="离散化" scheme="https:LotusLeaves.github.io/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    
      <category term="学习笔记" scheme="https:LotusLeaves.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>读入</title>
    <link href="https:LotusLeaves.github.io/2019/07/21/%E8%AF%BB%E5%85%A5/"/>
    <id>https:LotusLeaves.github.io/2019/07/21/读入/</id>
    <published>2019-07-21T10:49:29.793Z</published>
    <updated>2019-07-23T00:26:51.585Z</updated>
    
    <content type="html"><![CDATA[<h3 id="cin、cout"><a href="#cin、cout" class="headerlink" title="cin、cout"></a>cin、cout</h3><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">cout&lt;&lt;a+b;</span><br></pre></td></tr></table></figure><a id="more"></a><p>这种读入方式较慢，主要慢在<code>endl</code>上。</p><h3 id="scanf、printf"><a href="#scanf、printf" class="headerlink" title="scanf、printf"></a>scanf、printf</h3><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">printf(&quot;%d&quot;,a+b);</span><br></pre></td></tr></table></figure><p>这可以说是较快的读入方式了，但是许多毒瘤题还是会恶意卡。</p><h3 id="快读"><a href="#快读" class="headerlink" title="快读"></a>快读</h3><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">inline int read()</span><br><span class="line">&#123;</span><br><span class="line">    int k=0; char f=1,c=getchar();</span><br><span class="line">    while(c&gt;&apos;9&apos;||c&lt;&apos;0&apos;) if(c==&apos;-&apos;) &#123; f=-1; c=getchar(); &#125;</span><br><span class="line">    while(c&lt;=&apos;9&apos;&amp;&amp;c&gt;=&apos;0&apos;) &#123; k=k*10+c-&apos;0&apos;; c=getchar(); &#125;</span><br><span class="line">    return k*f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是本蒟蒻知道的最快的读入方式，好像没有题目会卡的吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;cin、cout&quot;&gt;&lt;a href=&quot;#cin、cout&quot; class=&quot;headerlink&quot; title=&quot;cin、cout&quot;&gt;&lt;/a&gt;cin、cout&lt;/h3&gt;&lt;p&gt;代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cout&amp;lt;&amp;lt;a+b;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="基础" scheme="https:LotusLeaves.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https:LotusLeaves.github.io/2019/07/20/hello-world/"/>
    <id>https:LotusLeaves.github.io/2019/07/20/hello-world/</id>
    <published>2019-07-20T09:56:21.188Z</published>
    <updated>2019-07-21T11:05:13.136Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
