<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[高精度模板]]></title>
    <url>%2F2019%2F08%2F27%2F%E9%AB%98%E7%B2%BE%E5%BA%A6%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[存一个高精度模板。 非原创，找不到原文地址了，如果作者看到了可以评论下博客地址，窝再挂上来 QAQ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int power = 1, base = 10, N = 10005, SL = 2000;char a[SL], b[SL];struct HP&#123; int a[N]; HP() &#123; memset(a, 0, sizeof(a)); &#125; HP(char *s) &#123; int len = strlen(s); memset(a, 0, sizeof(a)); a[0] = (len + power - 1) / power; for(int i = 0, t = 0, w; i &lt; len; w *= 10, i++) &#123; if(i % power == 0) w = 1, t++; a[t] += w * (s[i] - '0'); &#125; &#125; void add(int k) &#123; if(k || a[0]) a[++a[0]] = k; &#125; void re() &#123; reverse(a + 1, a + a[0] + 1); &#125; void print() &#123; printf("%d", a[a[0]]); for(int i = a[0] - 1; i &gt; 0; i--) printf("%0*d", power, a[i]); printf("\n"); &#125;&#125; p, q, ans;bool operator &lt; (const HP &amp;p, const HP &amp;q)&#123; if(p.a[0] &lt; q.a[0]) return true; if(p.a[0] &gt; q.a[0]) return false; for(int i = p.a[0]; i &gt; 0; i--) if(p.a[i] != q.a[i]) return p.a[i] &lt; q.a[i]; return false;&#125;HP operator + (const HP &amp;p, const HP &amp;q)&#123; HP c; c.a[0] = max(p.a[0], q.a[0]); for(int i = 1; i &lt;= c.a[0]; i++) &#123; c.a[i] += p.a[i] + q.a[i]; c.a[i + 1] += c.a[i] / base; c.a[i] %= base; &#125; if(c.a[c.a[0] + 1]) c.a[0]++; return c;&#125;HP operator - (const HP &amp;p, const HP &amp;q)&#123; HP c = p; for(int i = 1; i &lt;= c.a[0]; i++) &#123; c.a[i] -= q.a[i]; if(c.a[i] &lt; 0) &#123; c.a[i] += base; c.a[i + 1]--; &#125; &#125; while(c.a[0] &gt; 0 &amp;&amp; !c.a[c.a[0]]) c.a[0]--; return c;&#125;HP operator * (const HP &amp;p, const HP &amp;q)&#123; HP c; c.a[0] = p.a[0] + q.a[0] - 1; for(int i = 1; i &lt;= p.a[0]; i++) for(int j = 1; j &lt;= q.a[0]; j++) &#123; c.a[i + j - 1] += p.a[i] * q.a[j]; c.a[i + j] += c.a[i + j - 1] / base; c.a[i + j - 1] %= base; &#125; if(c.a[c.a[0] + 1]) c.a[0]++; return c;&#125;HP operator / (const HP &amp;p, const HP &amp;q)&#123; HP x, y; for(int i = p.a[0]; i &gt; 0; i--) &#123; y.add(p.a[i]), y.re(); while(!(y &lt; q)) y = y - q, x.a[i]++; y.re(); &#125; x.a[0] = p.a[0]; while(x.a[0] &gt; 0 &amp;&amp; !x.a[x.a[0]]) x.a[0]--; return x;&#125;int main()&#123; scanf("%s", a), scanf("%s", b); reverse(a, a + strlen(a)), reverse(b, b + strlen(b)); p = HP(a), q = HP(b); ans = p + q, ans.print(); ans = p - q, ans.print(); ans = p * q, ans.print(); ans = p / q, ans.print(); return 0;&#125;]]></content>
      <tags>
        <tag>高精</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P3373 【模板】线段树 2 题解]]></title>
    <url>%2F2019%2F08%2F27%2F%E6%B4%9B%E8%B0%B7%20P3373%20%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91%202%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Description给定一个长度为 $n$ 的数列和 $m$ 个操作，支持区间加法、区间乘法、区间求值。 数据范围：$n≤100000$ , $m≤100000$ Solution主要注意优先级问题。每次更改的时候，加法标记都要乘以乘法标记。$push_down$ 的时候加法标记还要乘以乘法标记。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;iostream&gt;#include &lt;cstdio&gt;#define int long long#define re register#define mid ((l + r) / 2)using namespace std;const int N = 500000;int n, m, p, opt, x, y, k;int a[N], sum[N], mul[N], add[N];inline int read()&#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123; if(c == '-') f = -1; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = x * 10 + c - 48; c = getchar(); &#125; return f * x;&#125;void push_up(int x) &#123; sum[x] = (sum[x * 2] + sum[x * 2 + 1]) % p; &#125;void push_down(int x, int l, int r)&#123; mul[x * 2] = (mul[x * 2] * mul[x]) % p; mul[x * 2 + 1] = (mul[x * 2 + 1] * mul[x]) % p; add[x * 2] = (add[x * 2] * mul[x] + add[x]) % p; add[x * 2 + 1] = (add[x * 2 + 1] * mul[x] + add[x]) % p; sum[x * 2] = (sum[x * 2] * mul[x] + add[x] * (mid - l + 1)) % p; sum[x * 2 + 1] = (sum[x * 2 + 1] * mul[x] + add[x] * (r - mid)) % p; mul[x] = 1, add[x] = 0; push_up(x);&#125;void build(int x, int l, int r)&#123; mul[x] = 1, add[x] = 0; if(l == r) &#123; sum[x] = a[l]; return ; &#125; build(x * 2, l, mid); build(x * 2 + 1, mid + 1, r); push_up(x);&#125;void upd_mul(int x, int l, int r, int stdl, int stdr, int k)&#123; if(stdl &lt;= l &amp;&amp; stdr &gt;= r) &#123; mul[x] = (mul[x] * k) % p, add[x] = (add[x] * k) % p; sum[x] = (sum[x] * k) % p; return ; &#125; if(stdl &gt; r || stdr &lt; l) return ; push_down(x, l, r); upd_mul(x * 2, l, mid, stdl, stdr, k); upd_mul(x * 2 + 1, mid + 1, r, stdl, stdr, k); push_up(x);&#125;void upd_add(int x, int l, int r, int stdl, int stdr, int k)&#123; if(stdl &lt;= l &amp;&amp; stdr &gt;= r) &#123; add[x] = (add[x] + k) % p; sum[x] = (sum[x] + (r - l + 1) * k); return ; &#125; if(stdl &gt; r || stdr &lt; l) return ; push_down(x, l, r); upd_add(x * 2, l, mid, stdl, stdr, k); upd_add(x * 2 + 1, mid + 1, r, stdl, stdr, k); push_up(x);&#125;int query(int x, int l, int r, int stdl, int stdr)&#123; if(stdl &lt;= l &amp;&amp; stdr &gt;= r) return sum[x] % p; if(stdl &gt; r || stdr &lt; l) return 0; push_down(x, l, r); return (query(x * 2, l, mid, stdl, stdr) + query(x * 2 + 1, mid + 1, r, stdl, stdr)) % p; push_up(x);&#125;signed main()&#123; n = read(), m = read(), p = read(); for(re int i = 1; i &lt;= n; i++) a[i] = read(); build(1, 1, n); for(re int i = 1; i &lt;= m; i++) &#123; opt = read(); if(opt == 1) &#123; x = read(), y = read(), k = read(); upd_mul(1, 1, n, x, y, k); &#125; if(opt == 2) &#123; x = read(), y = read(), k = read(); upd_add(1, 1, n, x, y, k); &#125; if(opt == 3) &#123; x = read(), y = read(); printf("%lld\n", query(1, 1, n, x, y)); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[背包九讲]]></title>
    <url>%2F2019%2F08%2F24%2F%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2%2F</url>
    <content type="text"><![CDATA[以下是学习背包九讲的学习笔记，只有前八讲。原文链接。 01背包问题Description有 $n$ 件物品，一个容量为 $m$ 的背包。每个物品有价值 $v$ 和重量 $w$。挑选一些物品放入背包，每个物品只能用一次，求最大价值。 Solution做法1设 $f[i][j]$ 为当前到第 $i$ 个物品，已经用 $j$ 容量的最大价值。 转移方程：$f[i][j]=max(f[i-1][j],f[i-1][j-w[i]]+v[i])$ 以上做法的时间、空间复杂度均为 $O(nm)$。 Code123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int v[200], w[200], n, m, f[2000][2000], ans = 0;int main()&#123; scanf("%d%d", &amp;m, &amp;n); for(int i = 1; i &lt;= n; i++) scanf("%d%d", &amp;w[i], &amp;v[i]); for(int i = 1; i &lt;= n; i++) for(int j = 0; j &lt;= m; j++) &#123; f[i][j] = f[i - 1][j]; if(j - v[i] &gt;= 0) f[i][j] = max(f[i][j], f[i - 1][j - w[i]] + v[i]); &#125; for(int i = 1; i &lt;= m; i++) ans = max(ans, f[n][i]); printf("%d", ans); return 0;&#125; 优化1时间复杂度难以优化，但可以优化空间复杂度到 $O(m)$。设 $f[i]$ 为表示容量为 $i$ 的背包能够得到的最大价值。 转移方程：$f[i]=max(f[i],f[i-w[i]]+v[i])$ Code1234567891011121314151617#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int n, m, v[200], w[200], f[2000];int main()&#123; scanf("%d%d", &amp;m, &amp;n); for(int i = 1; i &lt;= n; i++) scanf("%d%d", &amp;w[i], &amp;v[i]); memset(f, 0, sizeof(f)); for(int i = 1; i &lt;= n; i++) for(int j = m; j &gt;= w[i]; j--) f[j] = max(f[j], f[j - w[i]] + v[i]); printf("%d", f[m]); return 0;&#125; 完全背包问题Description还是 $01$ 背包问题，但不同的是每个物品可以用无限次。 Solution做法1还是设 $f[i][j]$ 为当前到第 $i$ 个物品，已经用 $j$ 容量的最大价值。 每次在循环内枚举 $k$ 作为当前物品使用的次数。直到当前容量再也无法放开为止。 可以看出这种做法的时空复杂度都很高。（因为在 $oj$ 上爆内存，所以下面的代码没有经过测试） Code12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int n, m, ans = 0, v[200], w[200], f[200][2000];int main()&#123; scanf("%d%d", &amp;m, &amp;n); for(int i = 1; i &lt;= n; i++) scanf("%d%d", &amp;w[i], &amp;v[i]); memset(f, 0, sizeof(f)); for(int i = 1; i &lt;= n; i++) for(int j = 0; j &lt;= m; j++) &#123; f[i][j] = f[i - 1][j]; for(int k = 1; j &gt;= k * w[i]; k++) f[i][j] = max(f[i][j], f[i - 1][j - w[i] * k] + v[i] * k); &#125; for(int i = 0; i &lt;= m; i++) ans = max(ans, f[n][i]); printf("%d", ans); return 0;&#125; 优化1先不考虑压缩空间，先来优化一下时间复杂度。之前 $i$ 这一层是由 $i-1$ 这一层更新来的，现在我们用 $i$ 这一层来平级地更新自己。会意一下，发现 $k$ 这一层不用循环了。（代码还是没有测试） Code12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int n, m, ans = 0, v[20000], w[20000], f[2000][2000];int main()&#123; scanf("%d%d", &amp;m, &amp;n); for(int i = 1; i &lt;= n; i++) scanf("%d%d", &amp;w[i], &amp;v[i]); memset(f, 0, sizeof(f)); for(int i = 1; i &lt;= n; i++) for(int j = 0; j &lt;= m; j++) &#123; f[i][j] = f[i - 1][j]; if(j &gt;= w[i]) f[i][j] = max(f[i][j], f[i][j - w[i]] + v[i]); &#125; for(int i = 0; i &lt;= m; i++) ans = max(ans, f[n][i]); printf("%d", ans); return 0;&#125; 优化2先来明确一下优化后的 $01$ 背包 $j$ 这层倒着循环的意义。比如在 $i$ 固定的情况下，$5$ 这个容量选择了第 $i$ 个物品，而 $7$ 这个容量又选择了 $i$ 和 $5$。可以发现 $i$ 这个物品已经选了两次了，不符合 $01$ 背包的定义。 现在可以重复选择了，$j$ 这一层正着循环就可以了。 优化3两个物品 $i$ 和 $j$，如果 $w[i]&gt;w[j]$ 且 $v[i]&lt;v[j]$，就把 $i$ 去掉，不用考虑。 Code1234567891011121314151617#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int n, m, v[200000], w[200000], f[2000000];int main()&#123; scanf("%d%d", &amp;m, &amp;n); for(int i = 1; i &lt;= n; i++) scanf("%d%d", &amp;w[i], &amp;v[i]); memset(f, 0, sizeof(f)); for(int i = 1; i &lt;= n; i++) for(int j = w[i]; j &lt;= m; j++) f[j] = max(f[j], f[j - w[i]] + v[i]); printf("%d", f[m]); return 0;&#125; 多重背包问题Description与 $01$ 背包相同，但每个物品可以取 $z$ 次。 Solution做法1把每个物品拆成 $z$ 个同样的物品，每个物品可以取一次。但是一旦 $z$ 比较大，这种做法在时空复杂度上就难以通过了。 优化1把每个物品拆成一些捆，每一捆按照 $2$ 的次方数来拆。最后剩下的物品绑成一捆。 证明：根据倍增的结论，某个数 $i$ 如果可以表示成 $2^0+2^1+2^2+ … +2^N$（设其为性质 $A$），那么任意一个数 $x$ $(1≤x≤i)$，也可以表示成 $2^a+2^b+2^c+ … +2^M$ $(0≤a&lt;b&lt;c&lt; … &lt;M≤N)$在此题中，如果物品数量 $z$ 满足性质 $A$，小于等于 $z$ 的任何一个物品都可以表示出来。否则，设 $p$ 为最大的 $&lt;z$ 而满足性质 $A$ 的数。设要取 $i$ 件物品，分类讨论：$1.$ $i≤p$，按照上述方法取。$2.$ $p&lt;i≤z$，先取最后一捆，再按照上述方法取。QED. Code123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstdio&gt;#define int long longusing namespace std;int n, m, cnt = 0, ans = 0, v[100000], w[100000], f[9001];signed main()&#123; scanf("%lld%lld", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) &#123; int a, b, c, x = 1; scanf("%lld%lld%lld", &amp;a, &amp;b, &amp;c); while(x &lt;= c) &#123; cnt++; v[cnt] = a * x, w[cnt] = b * x; c -= x, x *= 2; &#125; if(c) &#123; cnt++; v[cnt] = a * c; w[cnt] = b * c; &#125; &#125; n = cnt; for(int i = 1; i &lt;= n; i++) for(int j = m; j &gt;= v[i]; j--) f[j] = max(f[j], f[j - v[i]] + w[i]); for(int i = 1; i &lt;= m; i++) ans = max(ans, f[i]); printf("%lld", ans); return 0;&#125; 混合三种背包问题Description有一些物品只能取 $1$ 件，有一些物品可以取无数件，其他物品可以取 $z_i$ 件。 Solution首先考虑 $01$ 背包和完全背包的混合。只要判断一下当前物品的种类，看看是要顺序还是逆序循环。加上多重背包：按照上面的方法，拆开物品，将其变成 $01$ 背包（听说可以使用单调队列）。 Code123456789for(int i = 1; i &lt;= n; i++)&#123; if(can[i] == INF) for(int j = m; j &gt;= w[i]; j--) f[j] = max(f[j], f[j - w[i]] + val[i]); else for(int j = w[i]; j &lt;= m; j++) f[j] = max(f[j], f[j - w[i]] + val[i]);&#125; 二维费用背包问题Description对于每件物品，这件物品必须同时付出这两种代价，对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。 Solution设 $f[i][u][v]$ 为前 $i$ 个物品，两种代价分别为 $u$ 和 $v$ 能够得到的最大价值。转移方程：$f[i][u][v]=max(f[i-1][u-a[i]][v-b[i]]+val[i],f[i-1][u][v])$ 可以按照上面优化，去掉 $i$ 这一维。只要注意 $01$ 背包是逆序循环，完全背包是顺序循环就行了。代码以 $01$ 背包为例。 Code12345678910111213141516171819#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;const int N = 506;int n, m1, m2, a[N], b[N], val[N], f[N][N];int main()&#123; scanf("%d%d%d", &amp;n, &amp;m1, &amp;m2); for(int i = 1; i &lt;= n; i++) scanf("%d%d%d", &amp;a[i], &amp;b[i], &amp;val[i]); for(int i = 1; i &lt;= n; i++) for(int j = m1; j &gt;= a[i]; j--) for(int k = m2; k &gt;= a[i]; k--) f[j][k] = max(f[j][k], f[j - a[i]][k - b[i]] + val[i]); printf("%d", f[m1][m2]); return 0;&#125; 分组背包问题Description把 $n$ 个物品分为 $k$ 组，每一组物品最多只能选一个。 Solution问题变成了，你可以选择本组的一件，或者一件也不选。设 $f[i][j]$ 为前 $k$ 组物品花费 $j$ 能得到的价值。转移方程：$f[k][j]=max(f[k-1][j],f[k-1][j-w[i]]+val[i])$ （$i$ 属于第 $k$ 组） 可以按照上面的优化方法，把 $f$ 数组变成一维。保证每组只能选一个物品，容量的循环要在每一组物品的循环之外。具体看代码。 Code1234567for(int i = 1; i &lt;= k; i++) for(int j = m; j &gt; 0; j--) for(int h = 1; h &lt;= cnt[i]; h++) &#123; int v = belong[i][h]; f[j] = max(f[j], f[j - w[v]] + val[v]); &#125; 有依赖的背包问题Description如果选物品 $i$，必须选物品 $j$。 Solution如果把问题转化为一棵树，若 $j$ 依赖于 $i$，使 $i$ 成为 $j$ 的父亲。连出一虚拟根。只有选择了 $i$，才能选择其子树。 设 $f[i][j]$ 为以 $i$ 为根的子树，已经选择了 $j$ 个节点的最大价值。转移方程：$f[i][j]=max(f[i][j],f[s][k]+f[i][j-k])$ $(s$ 是 $i$ 的儿子，$0&lt;k&lt;j)$ 例题洛谷 P2014 选课 此题相当于给出 $n$ 个物品，背包容量为 $m$，每个物品的重量为 $1$，价值为 $s_i$，最大化价值。物品之间存在依赖关系。这样就把问题转化成了一般形式，按上面的思路解即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;const int N = 2333;struct edge&#123; int nxt, to;&#125; e[N];int n, m, fat, cnt = 0, s[N], f[N][N], head[N];void add(int x, int y)&#123; e[++cnt] = (edge) &#123; head[x], y &#125;; head[x] = cnt;&#125;void dp(int x, int fa)&#123; f[x][1] = s[x]; for(int i = head[x]; i; i = e[i].nxt) &#123; int v = e[i].to; if(v == fa) continue; dp(v, x); for(int j = m + 1; j &gt; 0; j--) for(int k = 1; k &lt; j; k++) f[x][j] = max(f[x][j], f[v][k] + f[x][j - k]); &#125;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d%d", &amp;fat, &amp;s[i]); add(fat, i); add(i, fat); &#125; dp(0, -1); printf("%d", f[0][m + 1]); return 0;&#125; 泛化背包问题Description每个物品没有固定的重量和价值。给它重量 $i$，就会得到价值 $h(i)$。 Solution设有泛化物品 $h$ 和 $l$，其中 $i(j)$ 表示给 $i$ 这个泛化物品设置 $j$ 费用能得到的价值。若 $f$ 满足 $f(v)=max(h(k)+l(v-k))$，则称 $f=h+l$。 实际上求最终结果的过程，就是不断求泛化物品之和的过程。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1197 [JSOI2008]星球大战 题解]]></title>
    <url>%2F2019%2F08%2F23%2F%E6%B4%9B%E8%B0%B7%20P1197%20%5BJSOI2008%5D%E6%98%9F%E7%90%83%E5%A4%A7%E6%88%98%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Description给你一张 $n$ 个点 $m$ 条边无向图，$k$ 次操作，每次去掉一个点和与其相连的所有边，问每次操作后的联通块个数。 数据范围：$1≤n≤400000 , 1≤m≤200000$ Solution每次删掉一个点不太容易，但是可以反过来想：先去掉所有该去掉的点，然后一个点一个点往上加。 使用并查集来判断联通情况。倒过来枚举 $k$ 个点，找到与该点相连的点，如果不在一个集合内，联通块个数 $-1$，把这两个点添加到同一个集合内。 注意：已经被去掉的点不算一个联通块。在每次加点的时候，联通块个数个数都要先 $+1$。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int N = 500000;struct edge&#123; int nxt, to;&#125; e[N];int n, m, k, cnt = 0, now;int head[N], f[N], a[N], b[N], c[N], ans[N];bool kill[N];void add(int x, int y)&#123; e[++cnt] = (edge) &#123; head[x], y &#125;; head[x] = cnt;&#125;int find(int x)&#123; if(f[x] == x) return x; return f[x] = find(f[x]);&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); memset(head, 0, sizeof(head)); for(int i = 1; i &lt;= m; i++) &#123; scanf("%d%d", &amp;a[i], &amp;b[i]); a[i]++, b[i]++; add(a[i], b[i]); add(b[i], a[i]); &#125; scanf("%d", &amp;k); memset(kill, false, sizeof(kill)); for(int i = 1; i &lt;= k; i++) &#123; scanf("%d", &amp;c[i]); c[i]++; kill[c[i]] = true; &#125; now = n - k; for(int i = 1; i &lt;= n; i++) f[i] = i; for(int i = 1; i &lt;= m; i++) if(!kill[a[i]] &amp;&amp; !kill[b[i]] &amp;&amp; find(a[i]) != find(b[i])) &#123; now--; f[find(a[i])] = find(b[i]); &#125; ans[k + 1] = now; for(int i = k; i &gt; 0; i--) &#123; kill[c[i]] = false; now++; for(int j = head[c[i]]; j; j = e[j].nxt) &#123; int v = e[j].to; if(!kill[v] &amp;&amp; find(v) != find(c[i])) &#123; now--; f[find(v)] = find(c[i]); &#125; &#125; ans[i] = now; &#125; for(int i = 1; i &lt;= k + 1; i++) printf("%d\n", ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P3957 跳房子 题解]]></title>
    <url>%2F2019%2F08%2F23%2F%E6%B4%9B%E8%B0%B7%20P3957%20%E8%B7%B3%E6%88%BF%E5%AD%90%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Description跳房子的游戏规则如下：在地面上有一个起点，起点右侧有 $n$ 个格子，在同一直线上。每个格子内有一个整数，表示到达该格子能得到的分数。规则规定：玩家每次都必须跳到当前位置右侧的一个格子内，可以在任意时刻结束游戏，获得的分数为曾经到达过的格子中的数字之和。 小 $R$ 研发了一款弹跳机器人参加游戏。机器人有一个缺陷，它每次向右弹跳的距离只能为固定的 $d$ 。如果小 $R$ 花 $g$ 个金币改进他的机器人，机器人的灵活性就增加 $g$，但是每次弹跳的距离至少为 $1$。具体而言，当 $g&lt;d$ 时，他的机器人每次可以选择向右弹跳的距离为 $d-g$ , $d-g+1$ , $d-g+2$ , $…$ , $d+g-2$ , $d+g-1$ , $d+g$；否则，他的机器人每次可以选择向右弹跳的距离为 $1$ , $2$ , $3$ , … , $d+g-2$ , $d+g-1$ , $d+g$。 小 $R$ 希望获得至少 $k$ 分，问他至少要花多少金币改造机器人。 数据范围：$1≤n≤500000 , 1≤d≤2000 , 1≤x_i , k≤10^9 , |s_i|&lt;10^5$ 做法1二分答案。用 $dp$ 来判断当前答案是否可行。$f[i]$ 表示跳到第 $i$ 个格子的最大得分。如果 $f[0-n]$ 中有任意一个 $&gt;=k$，当前答案可行。否则不可行。 另外注意，二分的右边界要取 $d$ 与第 $n$ 个格子到原点距离的最大值。 复杂度为 $O(n^2)$，可以得到 $50$ 分。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define int long longusing namespace std;const int N = 1000000;int n, d, k, l, r, ans = 0x3f3f3f3f, x[N], s[N], f[N];inline int read()&#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123; if(c == '-') f = -1; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = x * 10 + c - 48; c = getchar(); &#125; return f * x;&#125;int max_(int x, int y) &#123; return x &gt; y ? x : y; &#125;bool get(int g)&#123; memset(f, -0x3f, sizeof(f)); f[0] = 0; for(int i = 0; i &lt;= n; i++) &#123; int a = x[i] + max_(1, d - g), b = x[i] + d + g; for(int j = i + 1; j &lt;= n; j++) if(x[j] &gt;= a &amp;&amp; x[j] &lt;= b) f[j] = max_(f[j], f[i] + s[j]); &#125; for(int i = 0; i &lt;= n; i++) if(f[i] &gt;= k) return true; return false;&#125;signed main()&#123; n = read(), d = read(), k = read(); for(int i = 1; i &lt;= n; i++) x[i] = read(), s[i] = read(); l = 0, r = max_(d, x[n] + 1); while(l &lt;= r) &#123; int mid = (l + r) / 2; if(get(mid)) &#123; if(ans &gt; mid) ans = mid; r = mid - 1; &#125; else l = mid + 1; &#125; printf("%lld", ans); return 0;&#125; 单调队列优化可以发现格子每次向后移动，答案区间也跟着向后滑动。区间的两端点单调递增。 对 $dp$ 验证过程加一个单调队列优化。$q$ 存的是编号，$next$ 是当前轮到哪一个点入队。$i$ 每加一次就使 $next$ 以及后面进入区间的都入队，使前面不再区间内的出队。如果队列非空：f[i] = f[q[head]] + s[i] Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define int long longusing namespace std;const int N = 1000000;int n, d, k, l, r, head, tail, next, ans = 0x3f3f3f3f;int q[N], p[N], x[N], s[N], f[N];inline int read()&#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123; if(c == '-') f = -1; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = x * 10 + c - 48; c = getchar(); &#125; return f * x;&#125;int max_(int x, int y) &#123; return x &gt; y ? x : y; &#125;bool get(int g)&#123; memset(f, -0x3f, sizeof(f)); int head = 1, tail = 0, next = 0, ma = d + g, mi = d - g; mi = max_(mi, 1); f[0] = 0; for(int i = 1; i &lt;= n; i++) &#123; while(x[next] + mi &lt;= x[i]) &#123; while(head &lt;= tail &amp;&amp; f[q[tail]] &lt;= f[next]) tail--; q[++tail] = next; next++; &#125; while(head &lt;= tail &amp;&amp; x[q[head]] + ma &lt; x[i]) head++; if(head &lt;= tail) f[i] = f[q[head]] + s[i]; if(f[i] &gt;= k) return true; &#125; return false;&#125;signed main()&#123; n = read(), d = read(), k = read(); for(int i = 1; i &lt;= n; i++) x[i] = read(), s[i] = read(); x[0] = s[0] = 0; l = 0, r = max_(d, x[n] + 1); while(l &lt;= r) &#123; int mid = (l + r) / 2; if(get(mid)) &#123; if(ans &gt; mid) ans = mid; r = mid - 1; &#125; else l = mid + 1; &#125; if(ans != 0x3f3f3f3f) printf("%lld", ans); else printf("-1"); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>单调队列</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1030 求先序排列 题解]]></title>
    <url>%2F2019%2F08%2F22%2F%E6%B4%9B%E8%B0%B7%20P1030%20%E6%B1%82%E5%85%88%E5%BA%8F%E6%8E%92%E5%88%97%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Description给出一棵二叉树的中序与后序排列。求出它的先序排列（树结点用不同的大写字母表示）。 数据范围：长度 $≤8$ Solution做法中序遍历：ACGDBHZKX；后序遍历：CDGAHXKZB 根据后序遍历的性质，首先可以找到主根 B，输出。找到中序遍历中的 B，可以把整棵树分为 ACGD 和 HZKX；对应的后序遍历为 CDGA 和 HXKZ，分别递归。递归到中序遍历的长度 $=0$ 为止。 实现a.substr(0, k) 为截取并复制字符串 $a$ 中 $0$ 开始长度为 $k$ 的子串。a.substr(k) 为截取字符串 $a$ 从 $k$ 开始一直到最后的子串。a.find(c) 返回字符串 $a$ 中第一个找到字符串 $c$ 的位置。 Code12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;string s1, s2;void dfs(string a, string b)&#123; if(a.size() &gt; 0) &#123; char c = b[b.size() - 1]; int k = a.find(c); cout &lt;&lt; c; dfs(a.substr(0, k), b.substr(0, k)); dfs(a.substr(k + 1, a.size() - k), b.substr(k, b.size() - k - 1)); &#125;&#125;int main()&#123; cin &gt;&gt; s1 &gt;&gt; s2; dfs(s1, s2); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>搜索</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1070 道路游戏 题解]]></title>
    <url>%2F2019%2F08%2F21%2F%E6%B4%9B%E8%B0%B7%20P1070%20%E9%81%93%E8%B7%AF%E6%B8%B8%E6%88%8F%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Description环形马路上有 $n$ 个工厂，两个相邻工厂由一段马路连接。以某个工厂为起点，按顺时针将这 $n$ 个工厂编号为 $1-n$，第 $n$ 个工厂和第 $1$ 个工厂连接在一起。将连接工厂的 $n$ 段马路编号为 $1-n$，第 $i$ 段马路连接第 $i$ 个工厂和第 $i+1$ 个工厂 $(1≤i&lt;n)$，第 $n$ 段马路连接第 $n$ 个工厂和第 $1$ 个工厂。 每个单位时间，每段马路上会出现一些金币，不同时间同一段马路上出现的金币数可能不同。机器人能收集马路上的金币。机器人在工厂购买，机器人一旦被购买，会沿着环形马路按顺时针方向每个单位时间内行走一次，从当前所工厂到达下个工厂，将经过的马路上的金币收集给。环形马路上不能同时存在 $≥2$ 个机器人，每个机器人最多能在环形马路上行走 $p$ 次。每次购买需要给机器人设定行走次数，可以为 $1-p$ 之间的任意整数。机器人行走完规定次数之后会自动消失，必须立刻在任意一个工厂中购买一个机器人。 数据范围：$2≤n≤1000 , 1≤m≤1000 , 1≤p≤m$ 这是完整的题面，有一些细节 做法1$f[i]$ 表示第 $i$ 个时刻的最大值；$c[i]$ 表示在第 $i$ 个工厂购买机器人的花费；$sum[i][j]$ 表示第 $i$ 个时刻走到 $j$ 工厂马路上金币的总数。 转移方程（不考虑环的情况）： $f[i]=max(f[i],f[i-k]+sum[i][j]-sum[i-k][j-k]-c[j-k])$（$i$ 表示当前单位时间，$j$ 枚举工厂，$k$ 枚举步数） $sum$ 实际是一个二维前缀和，需要在 $dp$ 之前预处理出来。 Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int N = 1006;int n, m, p, f[N], r[N][N], sum[N][N], c[N];inline int read()&#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123; if(c == '-') f = -1; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = x * 10 + c - 48; c = getchar(); &#125; return f * x;&#125;int main()&#123; n = read(), m = read(), p = read(); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) r[i % n][j] = read(); for(int i = 0; i &lt; n; i++) scanf("%d", &amp;c[i]); for(int i = 1; i &lt;= m; i++) for(int j = 0; j &lt; n; j++) sum[i][j] = sum[i - 1][(j - 1 + n) % n] + r[j][i]; memset(f, -0x3f, sizeof(f)); //注意负数答案 f[0] = 0; for(int i = 1; i &lt;= m; i++) for(int j = 0; j &lt; n; j++) for(int k = 0; k &lt;= min(i, p); k++) &#123; int x = ((j - k) % n + n) % n; f[i] = max(f[i], f[i - k] + sum[i][j] - sum[i - k][x] - c[x]); &#125; printf("%d", f[m]); return 0;&#125; 复杂度分析$O(n^3)$？ 或许窝可以用事 (xia) 实 (bian) 来说明这个做法的复杂度是正确的。 用几个 $for$ 循环来模拟程序中 $dp$ 的复杂度，$n , m , p$ 取最大值。使计数器累加： 12345678910111213#include &lt;iostream&gt;using namespace std;int main()&#123; int a = 0; for(int i = 1; i &lt;= 1000; i++) for(int j = 1; j &lt;= 1000; j++) for(int k = 1; k &lt;= i; k++) // 这里实际上是循环到 min(i,1000) a++; printf("%d", &amp;a); return 0;&#125; 运行结果：7339584 单调队列优化反正 假装 时间复杂度是过不去毒瘤数据的。加一个单调队列优化。 看看这个式子（无环）f[i]=max(f[i],f[i-k]+sum[i][j]-sum[i-k][j-k]-c[j-k])用单调队列维护这个东西f[i]-sum[i][j]-c[j]（带 $k$ 的东西） 在无环的情况下，实际就是在每条对角线上 $dp$。所以给每条对角线建立一个单调队列，编号为 $j-i$。考虑有环的情况：当 $j$ 达到 $n$，它就会回到 $0$ 上去。而 $i$ 一直 $+1$。对角线每改一次就减掉一个 $n$。所以在有环的情况下，编号就改成了((j-i)%n+n)%n。其他不变。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int N = 1006;int n, m, p, f[N], r[N][N], sum[N][N], c[N], q[N][N];int head[N], tail[N], b[N][N];inline int read()&#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123; if(c == '-') f = -1; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = x * 10 + c - 48; c = getchar(); &#125; return f * x;&#125;int main()&#123; n = read(), m = read(), p = read(); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) r[i % n][j] = read(); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;c[i]); head[i] = 1, tail[i] = 1; q[i][tail[i]] = -c[i]; &#125; for(int i = 1; i &lt;= m; i++) for(int j = 0; j &lt; n; j++) sum[i][j] = sum[i - 1][(j - 1 + n) % n] + r[j][i]; memset(f, -0x3f, sizeof(f)); f[0] = 0; for(int i = 1; i &lt;= m; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; int id = ((j - i) % n + n) % n; while(head[id] &lt;= tail[id] &amp;&amp; b[id][head[id]] + p &lt; i) head[id]++; if(head[id] &lt;= tail[id]) f[i] = max(f[i], q[id][head[id]] + sum[i][j]); &#125; for(int j = 0; j &lt; n; j++) &#123; int id = ((j - i) % n + n) % n; int rec = f[i] - sum[i][j] - c[j]; while(head[id] &lt;= tail[id] &amp;&amp; q[id][tail[id]] &lt;= rec) tail[id]--; b[id][++tail[id]] = i; q[id][tail[id]] = rec; &#125; &#125; printf("%d", f[m]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>前缀和</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1886 滑动窗口 题解]]></title>
    <url>%2F2019%2F08%2F21%2F%E6%B4%9B%E8%B0%B7%20P1886%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Description有一堆共 $n$ 个数字，一个大小为 $k$ 的窗口。窗口从左边开始向右滑动，每次滑动一个单位，求每次滑动后窗口中的最大值和最小值。 数据范围：$n≤10^6$ Solution 全部摘抄自洛谷题解区 $@hankeke$ 的题解 样例 128 31 3 -1 -3 5 3 6 7 这是一道单调队列模板题。设 $q$ 为单调队列，$p$ 为对应编号。 $1.$ 由于此时队列为空，直接令 $1$ 进队。此时，$q=$ { $1$ } ,$p=$ { $1$ }。 $2.$ 现在 $3$ 面临抉择。假如把 $3$ 放进去，如果后面 $2$ 个数都比它大，那么 $3$ 在其有生之年就有可能成为最小的。此时，$q=$ { $1,3$ } $,p=$ { $1,2$ }。 $3.$ 下面出现了 $-1$。队尾元素 $3$ 比 $-1$ 大，那么只要 $-1$ 进队，$3$ 在其有生之年必定成为不了最小值，因为当下面 $3$ 被框起来，那么 $-1$ 也一定被框起来。$3$ 从队尾出队。同理，$1$ 从队尾出队。$-1$ 进队。此时 $q=$ { $-1$ } $,p=$ { $3$ } $4.$ 出现 $-3$，同上，$-1&gt;-3$，$-1$ 从队尾出队，$-3$ 从队尾进队。$q=$ { $-3$ } ，$p=$ { $4$ }。 $5.$ 出现 $5$，因为 $5&gt;-3$，同 $2.$ 分析，$5$ 还是有希望的，所以 $5$ 进队。此时，$q=$ { $-3,5$ } ，$p=$ { $4,5$ } $6.$ 出现 $3$。$3$ 先与队尾的5比较，$3&lt;5$，按照第 $3$ 条的分析，$5$ 从队尾出队。$3$ 再与 $-3$ 比较，同 $2.$ 分析，$3$ 进队。此时，$q=$ { $-3,3$ }，$p=$ { $4,6$ } $7.$ 出现 $6$。$6$ 与 $3$ 比较，因为 $3&lt;6$，所以 $3$ 不必出队。由于 $3$ 以前元素都 $&lt;3$，所以不必再比较，$6$ 进队。因为 $-3$ 此时已经在滑动窗口之外，所以 $-3$ 从队首出队。此时，$q=$ { $3,6$ }，$p=$ { $6,7$ } $8.$ 出现 $7$。队尾元素 $6$ 小于 $7$，$7$ 进队。此时，$q=$ { $3,6,7$ }，$p=$ { $6,7,8$ }。 Code123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int N = 2000000;int n, k, a[N], q[N], p[N];void min_()&#123; int head = 1, tail = 0; for(int i = 1; i &lt;= n; i++) &#123; while(tail &gt;= head &amp;&amp; a[i] &lt;= q[tail]) tail--; q[++tail] = a[i]; p[tail] = i; while(p[head] &lt;= i - k) head++; if(i &gt;= k) printf("%d ", q[head]); &#125; printf("\n");&#125;void max_()&#123; int head = 1, tail = 0; for(int i = 1; i &lt;= n; i++) &#123; while(tail &gt;= head &amp;&amp; a[i] &gt;= q[tail]) tail--; q[++tail] = a[i]; p[tail] = i; while(p[head] &lt;= i - k) head++; if(i &gt;= k) printf("%d ", q[head]); &#125;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;k); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); min_(), max_(); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分块]]></title>
    <url>%2F2019%2F08%2F20%2F%E5%88%86%E5%9D%97%2F</url>
    <content type="text"><![CDATA[思路分块是一种数据结构，往往把数据分为许多块来处理。让每一个 整块 维护一些信息。暴力区间两个端点的小块。时间复杂度一般带根号。 例题：loj 数列分块入门 1-9官方题解 数列分块入门 1Description给出一个长为 $n$ 的数列，以及 $n$ 个操作，操作涉及区间加法，单点查值。 数据范围：$1&lt;=n&lt;=50000 , -2^{31}&lt;=others,ans&lt;=2^{31}-1$ Solution把 $n$ 个数分成 $sqrt(n)$ 个块。$tag_i$ 表示第 $i$ 个块整个加上多少。 当遇到一个块 $i$ 被 $[l,r]$ 完全包含，使 $tag_i+=c$。如果块 $j$ 与 $[l,r]$ 有交集，暴力修改 $j$ 内被 $[l,r]$ 包含的元素。时间复杂度为 $O(n$ * $sqrt(n))$ 设点 $i$ 所属的块为 $be_i$，未更改之前的值为 $a_i$，它最终的值即为 $tag_{be_i}+a_i$ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define int long longusing namespace std;const int N = 100000;int opt, l, r, c, n, unit;int a[N], tag[N], be[N], kx[N], ky[N];inline int read()&#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123; if(c == '-') f = -1; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = x * 10 + c - 48; c = getchar(); &#125; return x * f;&#125;signed main()&#123; n = read(), unit = sqrt(n); memset(tag, 0, sizeof(tag)); be[0] = 0; for(int i = 1; i &lt;= n; i++) &#123; a[i] = read(); be[i] = (i - 1) / unit + 1; if(be[i] != be[i - 1]) kx[be[i]] = i; ky[be[i]] = i; &#125; for(int i = 1; i &lt;= n; i++) &#123; opt = read(), l = read(), r = read(), c = read(); if(opt == 0) &#123; for(int i = 1; i &lt;= be[n]; i++) &#123; if(l &lt;= kx[i] &amp;&amp; r &gt;= ky[i]) tag[i] += c; else if(l &gt; ky[i] || r &lt; kx[i]) ; else for(int j = kx[i]; j &lt;= ky[i]; j++) if(l &lt;= j &amp;&amp; r &gt;= j) a[j] += c; &#125; &#125; else printf("%d\n", a[r] + tag[be[r]]); &#125; return 0;&#125; 数列分块入门 2Description给出一个长为 $n$ 的数列，以及 $n$ 个操作，操作涉及区间加法，询问区间内小于某个值 $x$ 的元素个数。 数据范围：$1&lt;=n&lt;=50000 , -2^{31}&lt;=others, ans&lt;=2^{31}-1$ Solution对每个块内的元素进行排序，记录它原来的位置。区间加法如 $1$ 中操作。对于被完全包含的块，在块内二分，找到第一个大于等于 $x$ 的元素，该元素 $-1$ 到块的起点都是 $&lt;x$ 的元素。可以使用 $lower$_$bound$ 一个简单转换：$a_i+tag_{be_i}&lt;x$ -&gt; $a_i&lt;x-tag_{be_i}$ 对于不完整的块，直接暴力即可。总时间复杂度为 $O(n$*$sqrt(n)log_n)$ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#define re registerusing namespace std;const int N = 60000;struct node &#123; int x, y; &#125; b[N];int n, opt, l, r, c, unit, e = 0, f = 1;int tag[N], be[N], a[N], kx[N], ky[N];inline int read()&#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123; if(c == '-') f = -1; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = x * 10 + c - 48; c = getchar(); &#125; return x * f;&#125;bool cmp(node x, node y) &#123; return a[x.x] &lt; a[y.x]; &#125;int main()&#123; n = read(), unit = sqrt(n); memset(tag, 0, sizeof(tag)); for(re int i = 1; i &lt;= n; i++) &#123; a[i] = read(); b[i].x = b[i].y = i; e++; if(e == unit + 1) &#123; f++; e = 1; kx[f] = i; &#125; be[i] = f; ky[f] = i; &#125; for(re int i = 1; i &lt;= be[n]; i++) &#123; sort(b + kx[i], b + ky[i] + 1, cmp); sort(a + kx[i], a + ky[i] + 1); &#125; for(re int i = 1; i &lt;= n; i++) b[i].x = i; for(re int k = 1; k &lt;= n; k++) &#123; opt = read(), l = read(), r = read(), c = read(); if(opt == 0) &#123; for(re int i = 1; i &lt;= be[n]; i++) &#123; if(l &lt;= kx[i] &amp;&amp; r &gt;= ky[i]) tag[i] += c; else if(l &gt; ky[i] || r &lt; kx[i]) ; else &#123; for(re int j = kx[i]; j &lt;= ky[i]; j++) if(l &lt;= b[j].y &amp;&amp; r &gt;= b[j].y) a[j] += c; sort(b + kx[i], b + ky[i] + 1, cmp); sort(a + kx[i], a + ky[i] + 1); for(re int j = kx[i]; j &lt;= ky[i]; j++) b[j].x = j; &#125; &#125; &#125; if(opt == 1) &#123; int ans = 0; for(re int i = 1; i &lt;= be[n]; i++) &#123; if(l &lt;= kx[i] &amp;&amp; r &gt;= ky[i]) ans += lower_bound(a + kx[i], a + ky[i] + 1, c * c - tag[i]) - a - kx[i]; else if(l &gt; ky[i] || r &lt; kx[i]) ; else &#123; int tot = 0; for(re int j = kx[i]; j &lt;= ky[i]; j++) if(l &lt;= b[j].y &amp;&amp; r &gt;= b[j].y &amp;&amp; a[j] + tag[i] &lt; c * c) tot++; ans += tot; &#125; &#125; printf("%d\n", ans); &#125; &#125; return 0;&#125; 数列分块入门 3Description给出一个长为 $n$ 的数列，以及 $n$ 个操作，操作涉及区间加法，询问区间内小于某个值 $x$ 的前驱（比其小的最大元素） 数据范围：$1&lt;=n&lt;=100000 , -2^{31}&lt;=others, ans&lt;=2^{31}-1$ Solution对 $2$ 稍作改动。在二分的时候取 $max$ 作为答案。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#define re registerusing namespace std;const int N = 60000;struct node &#123; int x, y; &#125; b[N];int n, opt, l, r, c, unit;int tag[N], be[N], a[N], kx[N], ky[N];inline int read()&#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123; if(c == '-') f = -1; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = x * 10 + c - 48; c = getchar(); &#125; return x * f;&#125;bool cmp(node x, node y) &#123; return a[x.x] &lt; a[y.x]; &#125;int main()&#123; n = read(), unit = sqrt(n); memset(tag, 0, sizeof(tag)); be[0] = 0; for(re int i = 1; i &lt;= n; i++) &#123; a[i] = read(); b[i].x = b[i].y = i; be[i] = (i - 1) / unit + 1; if(be[i] != be[i - 1]) kx[be[i]] = i; ky[be[i]] = i; &#125; for(re int i = 1; i &lt;= be[n]; i++) &#123; sort(b + kx[i], b + ky[i] + 1, cmp); sort(a + kx[i], a + ky[i] + 1); &#125; for(re int i = 1; i &lt;= n; i++) b[i].x = i; for(re int k = 1; k &lt;= n; k++) &#123; opt = read(), l = read(), r = read(), c = read(); if(opt == 0) &#123; for(re int i = 1; i &lt;= be[n]; i++) &#123; if(l &lt;= kx[i] &amp;&amp; r &gt;= ky[i]) tag[i] += c; else if(l &gt; ky[i] || r &lt; kx[i]) ; else &#123; for(re int j = kx[i]; j &lt;= ky[i]; j++) if(l &lt;= b[j].y &amp;&amp; r &gt;= b[j].y) a[j] += c; sort(b + kx[i], b + ky[i] + 1, cmp); sort(a + kx[i], a + ky[i] + 1); for(re int j = kx[i]; j &lt;= ky[i]; j++) b[j].x = j; &#125; &#125; &#125; if(opt == 1) &#123; int ans = 0; for(re int i = 1; i &lt;= be[n]; i++) &#123; if(l &lt;= kx[i] &amp;&amp; r &gt;= ky[i]) ans += lower_bound(a + kx[i], a + ky[i] + 1, c * c - tag[i]) - a - kx[i]; else if(l &gt; ky[i] || r &lt; kx[i]) ; else &#123; int tot = 0; for(re int j = kx[i]; j &lt;= ky[i]; j++) if(l &lt;= b[j].y &amp;&amp; r &gt;= b[j].y &amp;&amp; a[j] + tag[i] &lt; c * c) tot++; ans += tot; &#125; &#125; printf("%d\n", ans); &#125; &#125; return 0;&#125; 数列分块入门 4Description给出一个长为 $n$ 的数列，以及 $n$ 个操作，操作涉及区间加法，区间求和。 数据范围：$1&lt;=n&lt;=50000 , -2^{31}&lt;=others, ans&lt;=2^{31}-1$ Solution$sum_i$ 表示第 $i$ 个块的和，$tag_i$表示第 $i$ 个块整体加上多少。在整块上打 $tag$，暴力两边时更改 $sum$ 和原值。查询时，每个点的值为 $a_i+tag_{be_i}$，每个块的值为 $sum_i+tag_i$*$(end-st+1)$ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define int long longusing namespace std;const int N = 60000;int n, opt, unit, l, r, c, e = 0, f = 1;int tag[N], be[N], a[N], kx[N], ky[N], sum[N];inline int read()&#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123; if(c == '-') f = -1; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = x * 10 + c - 48; c = getchar(); &#125; return f * x;&#125;signed main()&#123; n = read(), unit = sqrt(n); memset(sum, 0, sizeof(sum)); memset(tag, 0, sizeof(tag)); for(int i = 1; i &lt;= n; i++) &#123; a[i] = read(); e++; if(e == unit + 1) &#123; f++; e = 1; kx[f] = i; &#125; be[i] = f; ky[f] = i; &#125; for(int i = 1; i &lt;= n; i++) sum[be[i]] += a[i]; for(int i = 1; i &lt;= n; i++) &#123; opt = read(), l = read(), r = read(), c = read(); if(opt == 0) &#123; for(int i = 1; i &lt;= be[n]; i++) &#123; if(l &lt;= kx[i] &amp;&amp; r &gt;= ky[i]) tag[i] += c; else if(l &gt; ky[i] || r &lt; kx[i]) ; else for(int j = kx[i]; j &lt;= ky[i]; j++) if(l &lt;= j &amp;&amp; r &gt;= j) a[j] += c, sum[i] += c; &#125; &#125; else &#123; int ans = 0; for(int i = 1; i &lt;= be[n]; i++) &#123; if(l &lt;= kx[i] &amp;&amp; r &gt;= ky[i]) ans = (ans + sum[i] + tag[i] * (ky[i] - kx[i] + 1)) % (c + 1); else if(l &gt; ky[i] || r &lt; kx[i]) ; else for(int j = kx[i]; j &lt;= ky[i]; j++) if(l &lt;= j &amp;&amp; r &gt;= j) ans = (ans + a[j] + tag[i]) % (c + 1); &#125; printf("%d\n", ans % (c + 1)); &#125; &#125; return 0;&#125; 数列分块入门 5Description给出一个长为 $n$ 的数列，以及 $n$ 个操作，操作涉及区间开方，区间求和。 数据范围：$1&lt;=n&lt;=50000 , -2^{31}&lt;=others, ans&lt;=2^{31}-1$ Solution一个数经过几次开方之后就会变成 $0$ 或 $1$，此后再开方不会改变其值。可以标记一个块内所有数值是不是已经改变不了了。如果无法改变，直接跳过。否则暴力。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;const int N = 100000;int n, opt, l, r, c, unit;int a[N], tag[N], sum[N], be[N], kx[N], ky[N];inline int read()&#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123; if(c == '-') f = -1; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = x * 10 + c - 48; c = getchar(); &#125; return f * x;&#125;int judge(int x)&#123; for(int i = kx[x]; i &lt;= ky[x]; i++) if(a[i] != 0 &amp;&amp; a[i] != 1) return 0; return 1;&#125;int main()&#123; n = read(), unit = sqrt(n); be[0] = 0; memset(sum, 0, sizeof(sum)); for(int i = 1; i &lt;= n; i++) &#123; a[i] = read(); be[i] = (i - 1) / unit + 1; if(be[i] != be[i - 1]) kx[be[i]] = i; ky[be[i]] = i; sum[be[i]] += a[i]; &#125; memset(tag, 0, sizeof(tag)); for(int k = 1; k &lt;= n; k++) &#123; opt = read(), l = read(), r = read(), c = read(); if(opt == 0) &#123; for(int i = 1; i &lt;= be[n]; i++) &#123; if(l &lt;= kx[i] &amp;&amp; r &gt;= ky[i]) &#123; if(tag[i]) continue; for(int j = kx[i]; j &lt;= ky[i]; j++) &#123; sum[i] -= a[j]; a[j] = (int)sqrt(a[j]); sum[i] += a[j]; &#125; tag[i] = judge(i); &#125; else if(r &lt; kx[i] || l &gt; ky[i]) ; else &#123; if(tag[i]) continue; for(int j = kx[i]; j &lt;= ky[i]; j++) &#123; if(l &lt;= j &amp;&amp; r &gt;= j) &#123; sum[i] -= a[j]; a[j] = (int)sqrt(a[j]); sum[i] += a[j]; &#125; &#125; tag[i] = judge(i); &#125; &#125; &#125; if(opt == 1) &#123; int ans = 0; for(int i = 1; i &lt;= be[n]; i++) &#123; if(l &lt;= kx[i] &amp;&amp; r &gt;= ky[i]) ans += sum[i]; else if(l &gt; ky[i] || r &lt; kx[i]) ; else for(int j = kx[i]; j &lt;= ky[i]; j++) if(l &lt;= j &amp;&amp; r &gt;= j) ans += a[j]; &#125; printf("%d\n", ans); &#125; &#125; return 0;&#125; 数列分块入门 6Description给出一个长为 $n$ 的数列，以及 $n$ 个操作，操作涉及单点插入，单点询问，数据随机生成。 数据范围：$1&lt;=n&lt;=100000 , -2^{31}&lt;=others, ans&lt;=2^{31}-1$ Solution做法1使用链表维护，把当前数插入到 $l$ 前面，并使当前数加入 $l$ 所在块。对于每一次查询 $r$，先找出 $r$ 在哪一个块里，然后暴力这个块。 优化如果数据不是随机的，每个块的大小会远远大于 $sqrt(n)$。每 $sqrt(n)$ 次插入之后重新分块。（代码没有优化） Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;const int N = 300000;int n, unit, opt, l, r, c, cnt;int be[N], a[N], next[N], size[N], st[N];inline int read()&#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123; if(c == '-') f = -1; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = x * 10 + c - 48; c = getchar(); &#125; return f * x;&#125;int query(int x)&#123; int t = 0, ans; if(x == 0) return 0; for(int i = 1; i &lt;= be[n]; i++) &#123; int tot = t; if(t + size[i] &gt;= x) &#123; for(int j = st[i]; tot &lt; x; j = next[j]) tot++, ans = j; break; &#125; t += size[i]; &#125; return ans;&#125;int main()&#123; n = read(), unit = sqrt(n); cnt = n; be[0] = next[n] = 0; memset(size, 0, sizeof(size)); for(int i = 1; i &lt;= n; i++) &#123; a[i] = read(); be[i] = (i - 1) / unit + 1; size[be[i]]++; if(be[i] != be[i - 1]) st[be[i]] = i; next[i] = i + 1; &#125; for(int i = 1; i &lt;= n; i++) &#123; opt = read(), l = read(), r = read(), c = read(); if(opt == 0) &#123; int s = query(l), s1 = query(l - 1), b = be[s]; a[++cnt] = r; if(s1) next[s1] = cnt; next[cnt] = s; size[b]++; be[cnt] = b; if(st[b] == s) st[b] = cnt; &#125; else printf("%d\n", a[query(r)]); &#125; return 0;&#125; 数列分块入门 7Description给出一个长为 $n$ 的数列，以及 $n$ 个操作，操作涉及区间乘法，区间加法，单点询问。 数据范围：$1&lt;=n&lt;=100000 , -2^{31}&lt;=others, ans&lt;=2^{31}-1$ Solution设 $mul_i$ 为块 $i$ 整体乘上几，$add_i$ 为块 $i$ 整体加上几。块 $i$ 内的数乘以 $c$，$mul_i$ * $=c$，$add_i$ * $=c$。块 $i$ 内的数加上 $c$，$add_i+=c$。 特别注意：暴力两边的时候需要把乘法标记和加法标记都去掉，加到原始数组里面去。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define int long longusing namespace std;const int N = 200000, mod = 10007;int n, unit, opt, l, r, c;int be[N], kx[N], ky[N], a[N], mul[N], add[N];inline int read()&#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123; if(c == '-') f = -1; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = x * 10 + c - 48; c = getchar(); &#125; return f * x;&#125;signed main()&#123; n = read(), unit = sqrt(n); be[0] = 0; for(int i = 1; i &lt;= n; i++) &#123; a[i] = read(); be[i] = (i - 1) / unit + 1; if(be[i] != be[i - 1]) kx[be[i]] = i; ky[be[i]] = i; &#125; for(int i = 1; i &lt;= be[n]; i++) mul[i] = 1, add[i] = 0; for(int i = 1; i &lt;= n; i++) &#123; opt = read(), l = read(), r = read(), c = read(); if(opt == 0) &#123; for(int i = 1; i &lt;= be[n]; i++) &#123; if(l &lt;= kx[i] &amp;&amp; r &gt;= ky[i]) add[i] = (add[i] + c) % mod; else if(l &gt; ky[i] || r &lt; kx[i]) ; else &#123; for(int j = kx[i]; j &lt;= ky[i]; j++) &#123; a[j] = (a[j] * mul[i] + add[i]) % mod; if(l &lt;= j &amp;&amp; r &gt;= j) a[j] = (a[j] + c) % mod; &#125; mul[i] = 1, add[i] = 0; &#125; &#125; &#125; if(opt == 1) &#123; for(int i = 1; i &lt;= be[n]; i++) &#123; if(l &lt;= kx[i] &amp;&amp; r &gt;= ky[i]) &#123; mul[i] = (mul[i] * c) % mod; add[i] = (add[i] * c) % mod; &#125; else if(l &gt; ky[i] || r &lt; kx[i]) ; else &#123; for(int j = kx[i]; j &lt;= ky[i]; j++) &#123; a[j] = (a[j] * mul[i] + add[i]) % mod; if(l &lt;= j &amp;&amp; r &gt;= j) a[j] = (a[j] * c) % mod; &#125; mul[i] = 1, add[i] = 0; &#125; &#125; &#125; if(opt == 2) printf("%lld\n", (a[r] * mul[be[r]] + add[be[r]]) % mod); &#125; return 0;&#125; 数列分块入门 8Description给出一个长为 $n$ 的数列，以及 $n$ 个操作，操作涉及区间询问等于一个数 $c$ 的元素，并将这个区间的所有元素改为 $c$。 数据范围：$1&lt;=n&lt;=100000 , -2^{31}&lt;=others, ans&lt;=2^{31}-1$ Solution设$tag_i$ 表示块 $i$ 的值。$hav_i$ 表示块 $i$ 内的元素是否相同。 对于整块修改，$tag_i=c/hav_i=true$。对于两边，先把整块的 $tag$ 都去掉，再使 $hav_i=0$ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 200000;int n, unit, l, r, c;int a[N], be[N], kx[N], ky[N], tag[N], hav[N];inline int read()&#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123; if(c == '-') f = -1; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = x * 10 + c - 48; c = getchar(); &#125; return f * x;&#125;int main()&#123; n = read(), unit = sqrt(n); memset(hav, 0, sizeof(hav)); be[0] = 0; for(int i = 1; i &lt;= n; i++) &#123; a[i] = read(); be[i] = (i - 1) / unit + 1; if(be[i] != be[i - 1]) kx[be[i]] = i; ky[be[i]] = i; &#125; for(int k = 1; k &lt;= n; k++) &#123; l = read(), r = read(), c = read(); int ans = 0; for(int i = 1; i &lt;= be[n]; i++) &#123; if(l &lt;= kx[i] &amp;&amp; r &gt;= ky[i]) &#123; if(hav[i]) &#123; if(tag[i] == c) ans += (ky[i] - kx[i] + 1); continue; &#125; for(int j = kx[i]; j &lt;= ky[i]; j++) if(a[j] == c) ans++; &#125; else if(l &gt; ky[i] || r &lt; kx[i]) ; else &#123; for(int j = kx[i]; j &lt;= ky[i]; j++) &#123; if(hav[i]) a[j] = tag[i]; if(l &lt;= j &amp;&amp; r &gt;= j &amp;&amp; a[j] == c) ans++; &#125; hav[i] = 0; &#125; &#125; printf("%d\n", ans); for(int i = 1; i &lt;= be[n]; i++) &#123; if(l &lt;= kx[i] &amp;&amp; r &gt;= ky[i]) hav[i] = 1, tag[i] = c; else if(l &gt; ky[i] || r &lt; kx[i]) ; else &#123; for(int j = kx[i]; j &lt;= ky[i]; j++) &#123; if(hav[i]) a[j] = tag[i]; if(l &lt;= j &amp;&amp; r &gt;= j) a[j] = c; &#125; hav[i] = 0; &#125; &#125; &#125; return 0;&#125; 数列分块入门 9Description给出一个长为 $n$ 的数列，以及 $n$ 个操作，操作涉及询问区间的最小众数。 数据范围：$1&lt;=n&lt;=100000 , -2^{31}&lt;=others, ans&lt;=2^{31}-1$ Solution陈立杰大神的区间众数解题报告 此题与链接中题目不同之处在于，此题没有修改操作，并且需要离散化。 由于太菜，窝的代码 $T$ 了几个点，只能拿到 $92 pts$。 Code 92pts123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#define re registerusing namespace std;const int N = 100010, SN = 1000;vector &lt;int&gt; vec[N];int n, unit, l, r, now = 0, id = 0;int be[N], a[N], kx[N], ky[N], b[N], st[N], tot[N];int f[SN][SN], c[SN][SN], cnt[N];inline int read()&#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123; if(c == '-') f = -1; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = x * 10 + c - 48; c = getchar(); &#125; return f * x;&#125;int ask(int l, int r, int x)&#123; return upper_bound(vec[x].begin(), vec[x].end(), r) - lower_bound(vec[x].begin(), vec[x].end(), l);&#125;int solve(int l, int r)&#123; int maxx = c[be[l] + 1][be[r] - 1], id = f[be[l] + 1][be[r] - 1]; for(re int i = l; i &lt;= ky[be[l]]; i++) &#123; int x = ask(l, r, a[i]); if(x &gt; maxx || x == maxx &amp;&amp; a[i] &lt; id) maxx = x, id = a[i]; &#125; for(re int i = kx[be[r]]; i &lt;= r; i++) &#123; int x = ask(l, r, a[i]); if(x &gt; maxx || x == maxx &amp;&amp; a[i] &lt; id) maxx = x, id = a[i]; &#125; return st[id];&#125;int main()&#123; n = read(), unit = 200; be[0] = 0; for(re int i = 1; i &lt;= n; i++) &#123; a[i] = read(); b[i] = a[i]; be[i] = (i - 1) / unit + 1; if(be[i] != be[i - 1]) kx[be[i]] = i; ky[be[i]] = i; &#125; sort(b + 1, b + n + 1); int m = unique(b + 1, b + n + 1) - b - 1; for(re int i = 1; i &lt;= n; i++) &#123; int x = lower_bound(b + 1, b + m + 1, a[i]) - b; st[x] = a[i]; a[i] = x; vec[a[i]].push_back(i); &#125; for(re int i = 1; i &lt;= be[n]; i++) &#123; int maxx = 0, ans = 0x3f3f3f3f; memset(cnt, 0, sizeof(cnt)); for(re int j = i; j &lt;= be[n]; j++) &#123; for(re int k = kx[j]; k &lt;= ky[j]; k++) &#123; cnt[a[k]]++; if(cnt[a[k]] &gt; maxx || cnt[a[k]] == maxx &amp;&amp; a[k] &lt; ans) &#123; maxx = cnt[a[k]]; ans = a[k]; &#125; &#125; f[i][j] = ans; c[i][j] = maxx; &#125; &#125; memset(cnt, 0, sizeof(cnt)); for(re int i = 1; i &lt;= n; i++) &#123; l = read(), r = read(); if(l &gt; r) swap(l, r); if(be[l] == be[r] || be[l] == be[r] - 1) &#123; int maxx = 0, ans = 0x3f3f3f3f; for(re int j = l; j &lt;= r; j++) &#123; cnt[a[j]]++; if(cnt[a[j]] &gt; maxx || cnt[a[j]] == maxx &amp;&amp; a[j] &lt; ans) &#123; maxx = cnt[a[j]]; ans = a[j]; &#125; &#125; for(re int j = l; j &lt;= r; j++) cnt[a[j]] = 0; printf("%d\n", st[ans]); &#125; else printf("%d\n", solve(l, r)); &#125; return 0;&#125; 还是借(chao)鉴(xi)一下大佬 $hzwer$ 的 $std$ 吧…]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 2002 [Hnoi2010]Bounce 弹飞绵羊 题解]]></title>
    <url>%2F2019%2F08%2F18%2Fbzoj%202002%20%5BHnoi2010%5DBounce%20%E5%BC%B9%E9%A3%9E%E7%BB%B5%E7%BE%8A%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Description有 $n$ 个排成一行的弹力装置。第 $i$ 个弹力装置的弹力系数是 $k_i$，它会把绵羊弹到第 $i+k_i$ 个装置上。如果不存在第 $i+k_i$ 个装置，绵羊被弹飞。 $m$ 次询问，有两种操作：$opt=1$: 输入一个数 $i$，查询绵羊从第 $i$ 个装置开始需要多少次被弹飞；$opt=2$: 输入两个数 $i$ 和 $j$，表示将装置 $i$ 的弹力系数改为 $j$。 数据范围：$n&lt;=200000, m&lt;=100000$ Solution对 $n$ 个数进行分块。维护每个点 弹出所在块需要的次数 和 弹出后落在哪个节点上。从后往前扫描，方便每个节点继承后面节点的值。 预处理出所有点维护的信息，复杂度为 $O(n)$。修改 $i$ 节点的值时，不难发现与其有关的是当前块内编号比 $i$ 小的所有节点。修改这些节点维护的值。 最终复杂度为 $O(mlog_n)$。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;const int N = 200100;int n, m, x, y, e = 0, f = 1, opt, unit, t[N], be[N];struct node&#123; int num, id;&#125; cnt[N];inline int read()&#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123; if(c == '-') f = -1; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = x * 10 + c - 48; c = getchar(); &#125; return x * f;&#125;void update(int l, int r)&#123; for(int i = r; i &gt;= l; i--) &#123; if(be[i + t[i]] == be[i]) cnt[i].num = cnt[i + t[i]].num + 1, cnt[i].id = cnt[i + t[i]].id; else cnt[i].num = 1, cnt[i].id = i + t[i]; &#125;&#125;int main()&#123; n = read(), unit = sqrt(n); memset(be, 0, sizeof(be)); for(int i = 1; i &lt;= n; i++) &#123; t[i] = read(); e++; if(e == unit + 1) &#123; f++; e = 1; &#125; be[i] = f; &#125; update(1, n); m = read(); for(int i = 1; i &lt;= m; i++) &#123; opt = read(), x = read(); x++; if(opt == 1) &#123; int now = x, tot = 0; while(now &lt;= n) &#123; tot += cnt[now].num; now = cnt[now].id; &#125; printf("%d\n", tot); &#125; else &#123; y = read(); t[x] = y; update(unit * (be[x] - 1) + 1, x); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P2050 [NOI2012]美食节 题解]]></title>
    <url>%2F2019%2F08%2F16%2F%E6%B4%9B%E8%B0%B7%20P2050%20%5BNOI2012%5D%E7%BE%8E%E9%A3%9F%E8%8A%82%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Description有 $n$ 道菜，$m$ 个厨师。第 $j$ 个厨师做第 $i$ 道菜的时间为 $t_{i,j}$。有 $p_i$ 个人点第 $i$ 道菜。每个人的等待时间为 $0$ 到他点的菜品做完的时间。求最小的等待时间之和。 数据范围：$n&lt;=40, m&lt;=100, p&lt;=800, t_{i,j}&lt;=1000$ （其中 $p=∑p_i$） Solution把每道菜看做一个点，与源点连接，第 $i$ 道菜的流量为 $p_i$，费用为 $0$。把厨师拆成 $m$ * $p$ $(p=∑p_i)$ 个点，表示倒数第 $1–m$ 个时刻的所有厨师。把这些厨师与所有菜相连，流量为 $1$，费用为 $k$ * $a_{i,j}$。 证明：对于一道菜 $i$，其 被等待 的时间为 $k*a_{i,j}$（$k$ 为当前层数，$j$ 为当前厨师）。所有菜品的被等待时间相加即为所求的总等待时间。 最后把所有时刻的厨师与汇点相连，流量为 $1$，费用为 $0$。跑一遍费用流，即可得到 $60$ 分。 动态开点先建立初始图，第一层的所有厨师与所有菜品和汇点相连。第一次一定找到了一条增广路，经过了其中一个厨师。第二次把当前厨师的下一层与所有菜品和汇点连上，再找一次增广路。到了最后所有的边都被连上了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int N = 400006, INF = 1 &lt;&lt; 30;struct edge&#123; int nxt, to, w, f;&#125; e[N * 2];struct Pre&#123; int node, line;&#125; pre[N * 2];int n, m, s, t, w = 1, sum = 0, cnt = 1, cost = 0;int head[N], dis[N], vis[N], p[N], a[106][106], cook[N], dish[N];inline int read()&#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123; if(c == '-') f = -1; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = x * 10 + c - 48; c = getchar(); &#125; return x * f;&#125;int ID(int a, int b) &#123; return (a - 1) * sum + b + n; &#125;void add(int x, int y, int w, int f)&#123; e[++cnt] = (edge) &#123; head[x], y, w, f &#125;; head[x] = cnt; e[++cnt] = (edge) &#123; head[y], x, 0, -f &#125;; head[y] = cnt;&#125;bool spfa()&#123; for(int i = 0; i &lt;= t; i++) vis[i] = 0, dis[i] = 0x3f3f3f3f, pre[i].node = pre[i].line = -1; queue &lt;int&gt; q; q.push(s); dis[s] = 0; while(!q.empty()) &#123; int a = q.front(); q.pop(); vis[a] = 0; for(int i = head[a]; i; i = e[i].nxt) &#123; int v = e[i].to; if(dis[v] &gt; dis[a] + e[i].f &amp;&amp; e[i].w) &#123; dis[v] = dis[a] + e[i].f; pre[v].node = a; pre[v].line = i; if(!vis[v]) &#123; vis[v] = 1; q.push(v); &#125; &#125; &#125; &#125; return dis[t] == 0x3f3f3f3f ? false : true;&#125;void EK()&#123; while(spfa()) &#123; int minn = INF; for(int i = t; i != s; i = pre[i].node) minn = min(minn, e[pre[i].line].w); for(int i = t; i != s; i = pre[i].node) &#123; e[pre[i].line].w -= minn; e[pre[i].line ^ 1].w += minn; &#125; cost += minn * dis[t]; int u = pre[t].node; add(u + 1, t, 1, 0); for(int i = 1; i &lt;= n; i++) add(i, u + 1, 1, a[i][cook[u + 1]] * (dish[u + 1])); &#125;&#125;int main()&#123; n = read(); m = read(); for(int i = 1; i &lt;= n; i++) p[i] = read(), sum += p[i]; s = 0, t = sum * m + n + 1; for(int i = 1; i &lt;= n; i++) &#123; add(s, i, p[i], 0); for(int j = 1; j &lt;= m; j++) a[i][j] = read(); &#125; for(int i = 1; i &lt;= m; i++) &#123; for(int j = 1; j &lt;= sum; j++) &#123; int tmp = ID(i, j); cook[tmp] = i, dish[tmp] = j; &#125; &#125; for(int i = 1; i &lt;= m; i++) &#123; for(int j = 1; j &lt;= n; j++) add(j, ID(i, 1), 1, a[j][i]); add(ID(i, 1), t, 1, 0); &#125; EK(); printf("%d", cost); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P3916 图的遍历 题解]]></title>
    <url>%2F2019%2F08%2F16%2F%E6%B4%9B%E8%B0%B7%20P3916%20%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Description给出 $n$ 个点，$m$ 条边的有向图，对于每个点 $v$，求 $A(v)$ 表示从点 $v$ 出发，能到达的编号最大的点。 数据范围：$1&lt;=n,m&lt;=10^5$ Solution建边的时候建反向边。从编号最大的点开始，搜索其能够到达的所有 未标记 的点，将这些点标记。同时将这些点的答案记为当前点的编号。时间复杂度为 $O(n)$。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int N = 200006;struct edge&#123; int nxt, to;&#125; e[N];int n, m, a, b, cnt = 0, head[N], ans[N], vis[N];inline int read()&#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123; if(c == '-') f = -1; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = x * 10 + c - 48; c = getchar(); &#125; return x * f;&#125;void add(int x, int y)&#123; e[++cnt] = (edge) &#123; head[x], y &#125;; head[x] = cnt;&#125;void bfs(int x)&#123; queue &lt;int&gt; q; q.push(x); vis[x] = 1; while(!q.empty()) &#123; int a = q.front(); q.pop(); ans[a] = x; for(int i = head[a]; i; i = e[i].nxt) &#123; int v = e[i].to; if(!vis[v]) &#123; vis[v] = 1; q.push(v); &#125; &#125; &#125;&#125;int main()&#123; n = read(), m = read(); for(int i = 1; i &lt;= m; i++) &#123; a = read(), b = read(); add(b, a); &#125; memset(vis, 0, sizeof(vis)); for(int i = n; i &gt; 0; i--) &#123; if(vis[i]) continue; bfs(i); &#125; for(int i = 1; i &lt;= n; i++) printf("%d ", ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1441 砝码称重 题解]]></title>
    <url>%2F2019%2F08%2F16%2F%E6%B4%9B%E8%B0%B7%20P1441%20%E7%A0%9D%E7%A0%81%E7%A7%B0%E9%87%8D%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Description有 $n$ 个砝码，重量为 $a_1, a_2, a_3, …, a_n$。在去掉 $m$ 个砝码后，问最多能称量出多少不同的重量（不包括 $0$ ）。 数据范围：$n&lt;=20, m&lt;=4, m&lt;n, a_i&lt;=100$ Solution首先想到的是爆搜。先暴力去掉 $m$ 个砝码，然后暴力出能凑出多少种重量。最后答案取 $max$。会 $TLE$ 一些点。 可以使用 $dp$ 对第二步进行优化。设 $f[i]=(0/1)$ 为重量 $i$ 能否被凑出。注意是背包，不要忘记倒着循环。 Code123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int n, m, ans = 0, cnt = 0, res, f[100000], a[60], d[60];void dp()&#123; memset(f, 0, sizeof(f)); f[0] = 1; cnt = res = 0; for(int i = 1; i &lt;= n; i++) &#123; if(d[i]) continue; for(int j = cnt; j &gt;= 0; j--) if(f[j] &amp;&amp; !f[j + a[i]]) f[j + a[i]] = 1, res++; cnt += a[i]; &#125;&#125;void dfs(int x, int tot)&#123; if(tot == m) &#123; dp(); ans = max(ans, res); return ; &#125; if(x == n) return ; d[x + 1] = 1; dfs(x + 1, tot + 1); d[x + 1] = 0; dfs(x + 1, tot);&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]); dfs(0, 0); printf("%d", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1131 [ZJOI2007]时态同步 题解]]></title>
    <url>%2F2019%2F08%2F16%2F%E6%B4%9B%E8%B0%B7%20P1131%20%5BZJOI2007%5D%E6%97%B6%E6%80%81%E5%90%8C%E6%AD%A5%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Description一块电路板由若干个节点组成，用数字 $1,2,3…$ 进行标号。各个节点由若干不相交的导线连接。对于任何两个节点，存在且仅存在一条通路。第 $e$ 条边通过的时间为 $t_e$。 电路板上存在一个“激发器”，产生激励电流。中间节点对电流沿边进行转发。接受电流不再转发的节点称为 终止节点。所有终止节点接受电流的时间 全部相同 时，称为达到 时态同步 。 小 $Q$ 有一个道具，每次可以使任意边的通过时间 $+1$。求达到时态同步使用道具的最少次数。 数据范围：$n&lt;=500000, t_e&lt;=1000000$ Solution读入 $n$ 个点，$n-1$ 条边。可知是以激发器为根节点的一棵树。其终止节点为叶节点。从叶子节点开始，对于每一个节点 $i$，使其儿子到它的时间全部相同，累计答案。 可以在 $dfs$ 回溯的时候处理。时间复杂度为 $O(n)$ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define int long longusing namespace std;const int N = 2333333;struct edge&#123; int nxt, to, w;&#125; e[N];int n, s, a, b, c, cnt = 0, sum = 0, ans = 0, head[N], f[N];void add(int x, int y, int w)&#123; e[++cnt] = (edge) &#123; head[x], y, w&#125;; head[x] = cnt;&#125;void dfs(int x, int fa)&#123; for(int i = head[x]; i; i = e[i].nxt) if(e[i].to != fa) dfs(e[i].to, x); for(int i = head[x]; i; i = e[i].nxt) if(e[i].to != fa) f[x] = max(f[x], e[i].w); for(int i = head[x]; i; i = e[i].nxt) if(e[i].to != fa) ans += f[x] - e[i].w; for(int i = head[fa]; i; i = e[i].nxt) if(e[i].to == x) e[i].w += f[x];&#125;signed main()&#123; scanf("%lld%lld", &amp;n, &amp;s); for(int i = 1; i &lt; n; i++) &#123; scanf("%lld%lld%lld", &amp;a, &amp;b, &amp;c); add(a, b, c); add(b, a, c); &#125; memset(f, 0, sizeof(f)); dfs(s, 0); printf("%lld", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P2279 [HNOI2003]消防局的设立 题解]]></title>
    <url>%2F2019%2F08%2F15%2F%E6%B4%9B%E8%B0%B7%20P2279%20%5BHNOI2003%5D%E6%B6%88%E9%98%B2%E5%B1%80%E7%9A%84%E8%AE%BE%E7%AB%8B%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Description给定一棵 $n$ 个节点的树，定义树上两个节点 $a$、$b$ 的距离为从 $a$ 走到 $b$ 需要经过的边数。在任意一个节点建立消防站，可以覆盖到与其距离不超过 $2$ 的所有节点。求覆盖到树上每个节点最少需要的消防站个数。 数据范围：$n&lt;=1000$ Solution树形dp设 $f[i][0-4]$ 从 $i$ 这个节点向上覆盖 $2$ 到 $-2$ 层需要建立的最小消防站数。向上覆盖 $1$ 层是指覆盖 $i$ 所在的整个子树和 $i$ 的父亲。向上覆盖 $-1$ 层是指覆盖 $i$ 所在的子树除去 $i$。 可以看出 $f[i][0] ≥ f[i][1] ≥…≥ f[i][4]$ 设 $s$ 表示节点 $i$ 的儿子；$t$ 是 $i$ 的儿子且 $t≠s$。 $f[i][0]=1+∑f[s][4]$ $f[i][1]=min$ { $f[s][0]+∑f[t][3]$ } 和 $f[i][0]$ 的最小值。 $f[i][2]=min$ { $f[s][1]+∑f[t][2]$ } 和 $f[i][1]$ 的最小值。 $f[i][3]=∑f[s][2]$ 和 $f[i][2]$ 的最小值。 $f[i][4]=∑f[s][3]$ 和 $f[i][3]$ 的最小值。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define V e[i].tousing namespace std;const int N = 2000;struct edge&#123; int nxt, to;&#125; e[N];int n, a, b, cnt = 0, head[N], f[N][6];void dfs(int x)&#123; int sum1 = 0, sum2 = 0, sum3 = 0; if(!head[x]) &#123; f[x][0] = f[x][1] = f[x][2] = 1; return ; &#125; for(int i = head[x]; i; i = e[i].nxt) &#123; dfs(V); sum1 += f[V][3]; sum2 += f[V][2]; sum3 += f[V][4]; &#125; f[x][0] = f[x][1] = sum3 + 1; for(int i = head[x]; i; i = e[i].nxt) f[x][1] = min(f[x][1], sum1 - f[V][3] + f[V][0]); f[x][2] = f[x][1]; for(int i = head[x]; i; i = e[i].nxt) f[x][2] = min(f[x][2], sum2 - f[V][2] + f[V][1]); f[x][3] = min(f[x][2], sum2); f[x][4] = min(f[x][3], sum1);&#125;void add(int x, int y)&#123; e[++cnt] = (edge) &#123; head[x], y &#125;; head[x] = cnt;&#125;int main()&#123; scanf("%d", &amp;n); memset(head, 0, sizeof(head)); memset(f, 0, sizeof(f)); for(int i = 1; i &lt; n; i++) &#123; scanf("%d", &amp;a); add(a, i + 1); &#125; dfs(1); printf("%d", f[1][2]); return 0;&#125; 贪心每次选择一个深度最深的节点，想要覆盖这个节点，就需要在它的 兄弟/父亲/爷爷 中建立一个消防站。画图可以发现在其爷爷节点建立消防站可以覆盖到所有其他节点。 对所有节点进行排序，顺序遍历，取出 没有被覆盖过 的节点，在其爷爷节点建立一个消防站。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 2000;struct edge&#123; int nxt, to;&#125; e[N];int n, a, cnt = 0, max_d = 0, ans = 0;int vis[N], d[N], head[N], f[N], vis2[N], b[N];inline int read()&#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123; if(c == '-') f = -1; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = x * 10 + c - 48; c = getchar(); &#125; return x * f;&#125;void add(int x, int y)&#123; e[++cnt] = (edge) &#123; head[x], y &#125;; head[x] = cnt;&#125;void dfs(int x, int fa)&#123; f[x] = fa; d[x] = d[fa] + 1; for(int i = head[x]; i; i = e[i].nxt) &#123; int v = e[i].to; if(v != fa) dfs(v, x); &#125;&#125;void dfs2(int x, int tot)&#123; if(tot &gt; 2) return ; vis[x] = vis2[x] = 1; for(int i = head[x]; i; i = e[i].nxt) &#123; int v = e[i].to; if(!vis2[v]) dfs2(v, tot + 1); &#125;&#125;bool cmp(int a, int b) &#123; return d[a] &gt; d[b]; &#125;void solve()&#123; memset(vis, 0, sizeof(vis)); dfs(1, 0); sort(b + 1, b + n + 1, cmp); for(int i = 1; i &lt;= n; i++) &#123; if(vis[b[i]] == 1) continue; memset(vis2, 0, sizeof(vis2)); ans++; dfs2(f[f[b[i]]], 0); &#125;&#125;int main()&#123; n = read(); for(int i = 1; i &lt; n; i++) &#123; a = read(); b[i] = i; add(a, i + 1); add(i + 1, a); &#125; b[n] = n; solve(); printf("%d", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>树形dp</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1026 统计单词个数 题解]]></title>
    <url>%2F2019%2F08%2F15%2F%E6%B4%9B%E8%B0%B7%20P1026%20%E7%BB%9F%E8%AE%A1%E5%8D%95%E8%AF%8D%E4%B8%AA%E6%95%B0%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Description给出一个由小写字母组成的字符串（$p$ 行，每行 $20$ 个字母)，以及 $s$ 个单词。将此字母串分成 $k$ 份，使每份中包含的单词数之和最大（单词可以重叠，但其首字母不能重复使用）。 数据范围：$p&lt;=10, 1&lt;k&lt;=40, 1&lt;=s&lt;=6$ Solution设 $f[i][j]$ 为前 $i$ 个字符分成 $j$ 段的最大单词数；$cnt[i][j]$ 表示在 不考虑断开 的前提下 $[i,j]$ 区间的单词数。 首先预处理处 $cnt$ 数组。 转移方程：$f[i][j]=max(f[k][j-1]+cnt[k+1][i])$ （$k$ 为枚举上次断开的位置） Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;string str, s = "", w[10];int p, q, n, f[300][50], cnt[300][300];bool get(int x, int y)&#123; for(int i = 0; i &lt; w[y].size(); i++) if(s[i + x] != w[y][i]) return false; return true;&#125;void solve()&#123; for(int i = 0; i &lt; s.size(); i++) for(int j = i; j &lt; s.size(); j++) for(int k = i; k &lt;= j; k++) for(int h = 1; h &lt;= n; h++) if(k + w[h].size() - 1 &lt;= j &amp;&amp; get(k, h)) &#123; cnt[i][j]++; break; &#125;&#125;int main()&#123; scanf("%d%d", &amp;p, &amp;q); for(int i = 1; i &lt;= p; i++) &#123; cin &gt;&gt; str; s += str; &#125; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) cin &gt;&gt; w[i]; memset(cnt, 0, sizeof(cnt)); solve(); memset(f, 0, sizeof(f)); for(int i = 0; i &lt; s.size(); i++) for(int j = 1; j &lt;= min(i + 1, q); j++) for(int k = j - 2; k &lt; i; k++) f[i][j] = max(f[i][j], f[k][j - 1] + cnt[k + 1][i]); printf("%d", f[s.size() - 1][q]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1220 关路灯 题解]]></title>
    <url>%2F2019%2F08%2F15%2F%E6%B4%9B%E8%B0%B7%20P1220%20%E5%85%B3%E8%B7%AF%E7%81%AF%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Description有 $n$ 盏路灯，每盏路灯有坐标（单位 $m$）和功率（单位 $J$）。从第 $c$ 盏路灯开始，可以向左或向右关闭路灯。速度是 $1m/s$。求所有路灯的最少耗电。输入保证坐标单调递增。 数据范围：$1&lt;=n&lt;=50$ Solution设 $f[i][j][0/1]$ 为已经关闭区间 $[i,j]$ 所有灯，此时站在 左端点 $/$ 右端点 的最小耗电。 设 $d(i,j)$ 为第 $i$ 盏路灯和第 $j$ 盏路灯之间的距离，$w(i,j)$ 为 除了 $[i,j]$ 区间所有灯每秒钟的耗电总和。转移方程： $f[i][j][0]=max(f[i+1][j][0]+d(i,i+1)w(i+1,j),f[i+1][j][1]+d(i,j)w(i+1,j))$$f[i][j][1]=max(f[i][j-1][0]+d(i,j)w(i,j-1),f[i][j-1][1]+d(j-1,j)w(j,j-1))$ 使用前缀和维护耗电之和。 Code1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 60;struct light&#123; int pos, w;&#125; a[N];int n, c, sum[N], f[N][N][2];int main()&#123; scanf("%d%d", &amp;n, &amp;c); sum[0] = 0; for(int i = 1; i &lt;= n; i++) &#123; scanf("%d%d", &amp;a[i].pos, &amp;a[i].w); sum[i] = sum[i - 1] + a[i].w; &#125; memset(f, 0x3f, sizeof(f)); f[c][c][0] = f[c][c][1] = 0; for(int i = 1; i &lt;= n; i++) &#123; for(int l = 1; l + i &lt;= n; l++) &#123; int r = l + i; int d1 = sum[n] - sum[r] + sum[l]; int d2 = sum[n] - sum[r - 1] + sum[l - 1]; if(l &gt; c || r &lt; c) continue; f[l][r][0] = min(f[l][r][0], f[l + 1][r][0] + (a[l + 1].pos - a[l].pos) * d1); f[l][r][0] = min(f[l][r][0], f[l + 1][r][1] + (a[r].pos - a[l].pos) * d1); f[l][r][1] = min(f[l][r][1], f[l][r - 1][1] + (a[r].pos - a[r - 1].pos) * d2); f[l][r][1] = min(f[l][r][1], f[l][r - 1][0] + (a[r].pos - a[l].pos) * d2); &#125; &#125; printf("%d", min(f[1][n][0], f[1][n][1])); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>区间dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bzoj 1001 [BeiJing2006]狼抓兔子 题解]]></title>
    <url>%2F2019%2F07%2F26%2Fbzoj%201001%20%5BBeiJing2006%5D%E7%8B%BC%E6%8A%93%E5%85%94%E5%AD%90%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Description给定一 $n*m$ 的网格图。每条边有一个流量，兔子从左上角 $(1,1)$ 跑到右下角 $(n,m)$。流量为 $k$ 的边需要 $k$ 匹狼才能堵住。 求把兔子一网打尽所需的最少的狼。 如图： 数据范围：$n,m&lt;=1000$ Solution首先想到的是最大流 $=$ 最小割，可以跑一遍网络流。$TLE$。还有一个定理：平面图的最大流 $=$ 其对偶图的最短路。建对偶图，然后跑 $dijkstra+$ 堆优化。 平面图一边只在顶点处相交的图（其边不存在交叉） 对偶图定义对于每一个平面图， 都有与其相对应的对偶图。假设上面的例图是 $G$，与其对应的对偶图为 $G’$,那么对于 $G’$ 上面的每一个点， 对应的是 $G$ 里面的每一个面。 构建方式如图。对于每条边，用一条 垂直于 它的边连接对应的两个点（面） Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define M (n - 1) * (m - 1) * 2 + 1using namespace std;const int N = 1000006;struct edge&#123; int nxt, to,w;&#125; e[N * 6 + 106];struct node&#123; int id, dis; friend bool operator &lt; (node x, node y) &#123; return x.dis &gt; y.dis; &#125;&#125;;priority_queue &lt; node &gt; q;int n, m, a, cnt = 0, dis[N * 2 + 106], vis[N * 2 + 106], head[N * 2 + 106];inline int read()&#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123; if(c == '-') f = -1; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = x * 10 + c - 48; c = getchar(); &#125; return x * f;&#125;void add(int x, int y, int w)&#123; e[++cnt] = (edge) &#123; head[x], y, w &#125;; head[x] = cnt; e[++cnt] = (edge) &#123; head[y], x, w &#125;; head[y] = cnt;&#125;void dijkstra()&#123; memset(dis, 0x3f, sizeof(dis)); memset(vis, 0, sizeof(vis)); q.push((node) &#123; 0, 0 &#125;); dis[0] = 0; while(!q.empty()) &#123; int a = q.top().id; q.pop(); if(vis[a]) continue; vis[a] = 1; for(int i = head[a]; i; i = e[i].nxt) &#123; int v = e[i].to; if(dis[v] &gt; dis[a] + e[i].w) &#123; dis[v] = dis[a] + e[i].w; if(!vis[v]) q.push((node) &#123; v, dis[v] &#125;); &#125; &#125; &#125;&#125;int ID(int x, int y, int k)&#123; if(k == 1) return (x - 1) * (m - 1) * 2 + y; return (x - 1) * (m - 1) * 2 + y + m - 1;&#125;int main()&#123; n = read(), m = read(); memset(head, 0, sizeof(head)); if(n == 1 || m == 1) &#123; int f = 0x3f3f3f3f; for(int i = 1; i &lt; max(n, m); i++) &#123; a = read(); f = min(f, a); &#125; printf("%d", f); return 0; &#125; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt; m; j++) &#123; a = read(); if(i == 1) add(ID(i, j, 1), 0, a); else if(i == n) add(ID(i - 1, j, 2), M, a); else add(ID(i, j, 1), ID(i - 1, j, 2), a); &#125; for(int i = 1; i &lt; n; i++) for(int j = 1; j &lt;= m; j++) &#123; a = read(); if(j == 1) add(ID(i, j, 2), M, a); else if(j == m) add(ID(i, j - 1, 1), 0, a); else add(ID(i, j, 2), ID(i, j - 1, 1), a); &#125; for(int i = 1; i &lt; n; i++) for(int j = 1; j &lt; m; j++) &#123; a = read(); add(ID(i, j, 1), ID(i, j, 2), a); &#125; dijkstra(); printf("%d", dis[M]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>对偶图</tag>
        <tag>平面图</tag>
        <tag>网络流</tag>
        <tag>最短路</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P2782 友好城市 题解]]></title>
    <url>%2F2019%2F07%2F24%2F%E6%B4%9B%E8%B0%B7%20P2782%20%E5%8F%8B%E5%A5%BD%E5%9F%8E%E5%B8%82%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Description一条河，南北岸各有 $n$ 座城市，每座城市有一个坐标。北岸的每座城市在南岸有一个“友好城市”，且不同城市的友好城市不同。如果在每对友好城市之间连边，在这些边互不相交的情况下使边数最多。 数据范围：$n&lt;=2e5, x_i&lt;=1e6$ Solution$O(n^2)$ 的做法：先把南岸或者北岸排序，然后找另一边的最长不下降子序列。但是过不了这题。 $O(nlog_{n})$ 的做法：优化找最长不下降子序列的过程，使用 $upper$ _ $bound$ 函数找到第一个比当前大的数，替换它。 Code1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 300005;struct city&#123; int s, n;&#125; a[N];int n, len = 0, d[N];bool cmp(city a, city b) &#123; return a.n &lt; b.n; &#125;int main()&#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) scanf("%d%d", &amp;a[i].s, &amp;a[i].n); sort(a + 1, a + n + 1, cmp); d[++len] = a[1].s; //初始化 for(int i = 2; i &lt;= n; i++) &#123; int id = upper_bound(d + 1, d + len + 1, a[i].s) - d; d[id] = a[i].s; //当前北岸编号较大，南岸编号较小，一定比刚才优 if(id &gt; len) len++; //如果新开了一个位置 &#125; printf("%d", len); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P2470 [SCOI2007]压缩 题解]]></title>
    <url>%2F2019%2F07%2F23%2F%E6%B4%9B%E8%B0%B7%20P2470%20%5BSCOI2007%5D%E5%8E%8B%E7%BC%A9%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Description一个由小写字母组成的字符串，压缩其重复信息。压缩后的字符串除了小写字母外还可以（但不必）包含大写字母 $R$ 与 $M$，其中 $M$ 标记重复串的开始，$R$ 重复从上一个 $M$（如果当前位置左边没有 $M$，则从串的开始算起）开始的解压结果（称为缓冲串）。 串 $bcdcdcdcd$ 的解压过程： 数据范围：$1&lt;=n&lt;=50$ Solution设 $f[i][j]$ 为当前处理到第 $i$ 个字符，上个 $M$ 放在了第 $j$ 个字符之后的最小长度。更新的时候使用刷表法。 有三种情况： $1.$ 什么也不做：$f[i+1][j]=min(f[i+1][j],f[i][j]+1)$ $2.$ 在后面放一个 $M$：$f[i][i]=min(f[i][i],f[i][j]+1)$ $3.$ 在后面放一个 $R$: $f[2i+j][j]=min(f[2i+j][j],f[i][j]+1)$ 注意，这里需要判断一下区间 $(j,i]$ 和区间 $(i,i*2-j]$ 是不是完全相同。完全相同才能执行 $3.$这一步。 Code12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;char s[100];int f[60][60], n, ans = 0x3f3f3f3f;bool get(int mid, int len)&#123; if(mid + len &gt; n) return false; for(int k = 1; k &lt;= len; k++) if(s[mid - len + k] != s[mid + k]) return false; return true;&#125;int main()&#123; scanf("%s", s + 1); memset(f, 0x3f, sizeof(f)); n = strlen(s + 1); f[0][0] = 0; for(int i = 0; i &lt;= n; i++) &#123; for(int j = 0; j &lt;= i; j++) &#123; f[i][i] = min(f[i][i],f[i][j] + 1); f[i + 1][j] = min(f[i + 1][j],f[i][j] + 1); if(get(i, i - j)) f[i * 2 - j][j] = min(f[i * 2 - j][j], f[i][j] + 1); &#125; &#125; for(int i = 0; i &lt;= n; i++) ans = min(ans, f[n][i]); printf("%d", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JoyOI 数字三角形2 题解]]></title>
    <url>%2F2019%2F07%2F23%2FJoyOI%20%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A22%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Description给定数字三角形，要求最后答案 $mod$ $100$ 最大。 数据范围：$n&lt;=25$ Solution设 $bool$ $f[i][j][k]$ 为走到 $(i,j)$ 这个点 $mod$ $100$ 能不能得到 $k$。更新使用刷表法。 Code12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;int n, f[100][100][150], a[50][50];int main()&#123; memset(f, 0, sizeof(f)); scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= i; j++) scanf("%d", &amp;a[i][j]); f[1][1][a[1][1] % 100] = 1; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= i; j++) for(int k = 0; k &lt; 100; k++) if(f[i][j][k]) &#123; f[i + 1][j][(k + a[i + 1][j]) % 100] = 1; f[i + 1][j + 1][(k + a[i + 1][j + 1]) % 100] = 1; &#125; int ans = -0x3f3f3f3f; for(int i = 1; i &lt;= n; i++) for(int k = 0; k &lt; 100; k++) if(f[n][i][k]) ans = max(ans, k); printf("%d", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P4302 [SCOI2003]字符串折叠 题解]]></title>
    <url>%2F2019%2F07%2F23%2F%E6%B4%9B%E8%B0%B7%20P4302%20%5BSCOI2003%5D%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8A%98%E5%8F%A0%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Description折叠的定义如下： $1.$ 一个字符串可以看成它自身的折叠。记作 $S=S$. $2.$ $X(S)$ 是 $X(X&gt;1)$ 个 $S$ 连接在一起的串的折叠。记作 $X(S)=SSSS…S$ ( $X$ 个 $S$ )。 如果 $A=A’$, $B=B’$，则 $AB=A’B’$ 例如，因为 $3(A)=AAA$, $2(B)=BB$，所以 $3(A)C2(B)=AAACBB$，而 $2(3(A)C)2(B)=AAACAAACBB$ 求给定字符串的最短折叠。 数据范围：$len&lt;=100$ Solution设 $f[i][j]$ 为表示区间 $[i,j]$ 折叠的最小长度。 $get(i,j,k,h)$ 表示区间 $[i,j]$ 和区间 $[k,h]$ 能否折叠。 如果能够折叠：$f[i][j]=min(f[i][j],f[i][k]+2+cal((j-i+1)/(k-i+1)))$ （其中 $cal(x)$ 返回的是 $x$ 的位数） 否则：$f[i][j]=min(f[i][j],f[i][k]+f[k+1][j])$ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 300;string s;int f[N][N], n;bool get(int x1, int y1, int x2, int y2)&#123; if((y2 - x1 + 1) % (y1 - x1 + 1) != 0) return false; int len = y1 - x1 + 1; for(int i = x2; i &lt;= y2; i++) &#123; if(s[i] != s[i - len]) return false; &#125; return true;&#125;int cal(int k)&#123; int ans = 0; while(k) &#123; k /= 10; ans++; &#125; return ans;&#125;int main()&#123; cin &gt;&gt; s; n = s.size(); for(int i = 0; i &lt; n; i++) f[i][i] = 1; for(int i = 1; i &lt; n; i++) &#123; for(int l = 0; l + i &lt; n; l++) &#123; int r = l + i; f[l][r] = r - l + 1; for(int k = l; k &lt; r; k++) &#123; if(!get(l, k, k + 1, r)) f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r]); else f[l][r] = min(f[l][r], f[l][k] + 2 + cal((r - l + 1) / (k - l + 1))); &#125; &#125; &#125; printf("%d", f[0][n - 1]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>区间dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P4766 [CERC2014]Outer space invaders 题解]]></title>
    <url>%2F2019%2F07%2F23%2F%E6%B4%9B%E8%B0%B7%20P4766%20%5BCERC2014%5DOuter%20space%20invaders%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Description有 $n$ 个外星人进攻，第 $i$ 个外星出现时间为 $a_i$ ，距离为 $d_i$ ,必须在时间 $b_i$ 前被消灭。 你的武器可以设置任何给定的功率。如果被设置了功率 $R$，它会摧毁距离在 $R$ 及以内的所有外星人，同时消耗 $R$ 单位的燃料。 求存活条件下最少要消耗多少燃料。 数据范围：$n&lt;=300 , 1&lt;=a_i&lt;b_i&lt;=10000 , 1&lt;=d_i&lt;=10000$ Solution设 $f[i][j]$ 为消灭 $i–j$ 时间内外星人的最少花费。设这段区间最晚出现的外星人编号为 $id$，则转移方程为： $f[i][j]=min(f[i][j],f[i][k-1]+a[id].d+f[k+1][j])$ 如果开二维数组，$10000$ 有点太大。题面只出现了 $300$ 个外星人，可以离散化。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 50005;struct node&#123; int l, r, d;&#125; a[maxn];int T, n, m, t[maxn], cnt, f[700][700];void solve()&#123; cnt = 0; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d%d%d", &amp;a[i].l, &amp;a[i].r, &amp;a[i].d); t[++cnt] = a[i].l; t[++cnt] = a[i].r; &#125; sort(t + 1, t + cnt + 1); m = unique(t + 1, t + cnt + 1) - t - 1; for(int i = 1; i &lt;= n; i++) &#123; a[i].l = lower_bound(t + 1, t + m + 1, a[i].l) - t; a[i].r = lower_bound(t + 1, t + m + 1, a[i].r) - t; &#125; for(int i = 0; i &lt;= m; i++) for(int l = 1; l + i &lt;= m; l++) &#123; int r = l + i, id = 0; for(int j = 1; j &lt;= n; j++) if(a[j].l &gt;= l &amp;&amp; a[j].r &lt;= r &amp;&amp; (!id || a[j].d &gt; a[id].d)) id = j; if(!id) &#123; f[l][r] = 0; continue; &#125; f[l][r] = 0x3f3f3f3f; for(int k = a[id].l; k &lt;= a[id].r; k++) f[l][r] = min(f[l][r], f[l][k - 1] + f[k + 1][r] + a[id].d); &#125; printf("%d\n", f[1][m]);&#125;int main()&#123; scanf("%d", &amp;T); while(T--) solve(); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>区间dp</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[离散化]]></title>
    <url>%2F2019%2F07%2F23%2F%E7%A6%BB%E6%95%A3%E5%8C%96%2F</url>
    <content type="text"><![CDATA[定义离散化，把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。也就是说，我们不关心数据的真实大小，只关心数据的 相对 大小。比如我们要把 $1e5$ 个范围是 $1e9$ 的数进行并查集。 代码12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1000005;int n, m, a[N], t[N];int main()&#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); t[i] = a[i]; &#125; sort(t + 1, t + n + 1); m = unique(t + 1, t + n + 1) - t - 1; for(int i = 1; i &lt;= n; i++) a[i] = lower_bound(t + 1, t + m + 1, a[i]) - t; return 0;&#125; 其中 $unique$ 返回的是去重后的 尾地址 ，需要减去首地址才能使用。$lower$_$bound$ 返回的是左闭右开区间 $[first,last)$ 中第一个大于等于 $val$ 的元素地址（也就是说 $last$ 是越界的）]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>离散化</tag>
      </tags>
  </entry>
</search>
