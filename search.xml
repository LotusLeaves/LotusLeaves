<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[bzoj 1001 [BeiJing2006]狼抓兔子 题解]]></title>
    <url>%2F2019%2F07%2F26%2Fbzoj%201001%20%5BBeiJing2006%5D%E7%8B%BC%E6%8A%93%E5%85%94%E5%AD%90%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Description给定一 $n*m$ 的网格图。每条边有一个流量，兔子从左上角 $(1,1)$ 跑到右下角 $(n,m)$。流量为 $k$ 的边需要 $k$ 匹狼才能堵住。 求把兔子一网打尽所需的最少的狼。 如图： 数据范围：$n,m&lt;=1000$ Solution首先想到的是最大流 $=$ 最小割，可以跑一遍网络流。$TLE$。还有一个定理：平面图的最大流 $=$ 其对偶图的最短路。建对偶图，然后跑 $dijkstra+$ 堆优化。 平面图一边只在顶点处相交的图（其边不存在交叉） 对偶图定义对于每一个平面图， 都有与其相对应的对偶图。假设上面的例图是 $G$，与其对应的对偶图为 $G’$,那么对于 $G’$ 上面的每一个点， 对应的是 $G$ 里面的每一个面。 构建方式如图。对于每条边，用一条 垂直与 它的边连接对应的两个点（面） Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define M (n - 1) * (m - 1) * 2 + 1using namespace std;const int N = 1000006;struct edge&#123; int nxt, to,w;&#125; e[N * 6 + 106];struct node&#123; int id, dis; friend bool operator &lt; (node x, node y) &#123; return x.dis &gt; y.dis; &#125;&#125;;priority_queue &lt; node &gt; q;int n, m, a, cnt = 0, dis[N * 2 + 106], vis[N * 2 + 106], head[N * 2 + 106];inline int read()&#123; char c = getchar(); int x = 0, f = 1; while(c &lt; '0' || c &gt; '9') &#123; if(c == '-') f = -1; c = getchar(); &#125; while(c &gt;= '0' &amp;&amp; c &lt;= '9') &#123; x = x * 10 + c - 48; c = getchar(); &#125; return x * f;&#125;void add(int x, int y, int w)&#123; e[++cnt] = (edge) &#123; head[x], y, w &#125;; head[x] = cnt; e[++cnt] = (edge) &#123; head[y], x, w &#125;; head[y] = cnt;&#125;void dijkstra()&#123; memset(dis, 0x3f, sizeof(dis)); memset(vis, 0, sizeof(vis)); q.push((node) &#123; 0, 0 &#125;); dis[0] = 0; while(!q.empty()) &#123; int a = q.top().id; q.pop(); if(vis[a]) continue; vis[a] = 1; for(int i = head[a]; i; i = e[i].nxt) &#123; int v = e[i].to; if(dis[v] &gt; dis[a] + e[i].w) &#123; dis[v] = dis[a] + e[i].w; if(!vis[v]) q.push((node) &#123; v, dis[v] &#125;); &#125; &#125; &#125;&#125;int ID(int x, int y, int k)&#123; if(k == 1) return (x - 1) * (m - 1) * 2 + y; return (x - 1) * (m - 1) * 2 + y + m - 1;&#125;int main()&#123; n = read(), m = read(); memset(head, 0, sizeof(head)); if(n == 1 || m == 1) &#123; int f = 0x3f3f3f3f; for(int i = 1; i &lt; max(n, m); i++) &#123; a = read(); f = min(f, a); &#125; printf("%d", f); return 0; &#125; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt; m; j++) &#123; a = read(); if(i == 1) add(ID(i, j, 1), 0, a); else if(i == n) add(ID(i - 1, j, 2), M, a); else add(ID(i, j, 1), ID(i - 1, j, 2), a); &#125; for(int i = 1; i &lt; n; i++) for(int j = 1; j &lt;= m; j++) &#123; a = read(); if(j == 1) add(ID(i, j, 2), M, a); else if(j == m) add(ID(i, j - 1, 1), 0, a); else add(ID(i, j, 2), ID(i, j - 1, 1), a); &#125; for(int i = 1; i &lt; n; i++) for(int j = 1; j &lt; m; j++) &#123; a = read(); add(ID(i, j, 1), ID(i, j, 2), a); &#125; dijkstra(); printf("%d", dis[M]); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>对偶图</tag>
        <tag>平面图</tag>
        <tag>网络流</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P2782 友好城市 题解]]></title>
    <url>%2F2019%2F07%2F24%2F%E6%B4%9B%E8%B0%B7%20P2782%20%E5%8F%8B%E5%A5%BD%E5%9F%8E%E5%B8%82%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Description一条河，南北岸各有 $n$ 座城市，每座城市有一个坐标。北岸的每座城市在南岸有一个“友好城市”，且不同城市的友好城市不同。如果在每对友好城市之间连边，在这些边互不相交的情况下使边数最多。 数据范围：$n&lt;=2e5, x_i&lt;=1e6$ Solution$O(n^2)$ 的做法：先把南岸或者北岸排序，然后找另一边的最长不下降子序列。但是过不了这题。 $O(nlog_{n})$ 的做法：优化找最长不下降子序列的过程，使用 $upper$ _ $bound$ 函数找到第一个比当前大的数，替换它。 Code1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 300005;struct city&#123; int s, n;&#125; a[N];int n, len = 0, d[N];bool cmp(city a, city b) &#123; return a.n &lt; b.n; &#125;int main()&#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) scanf("%d%d", &amp;a[i].s, &amp;a[i].n); sort(a + 1, a + n + 1, cmp); d[++len] = a[1].s; //初始化 for(int i = 2; i &lt;= n; i++) &#123; int id = upper_bound(d + 1, d + len + 1, a[i].s) - d; d[id] = a[i].s; //当前北岸编号较大，南岸编号较小，一定比刚才优 if(id &gt; len) len++; //如果新开了一个位置 &#125; printf("%d", len); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>dp</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JoyOI 中中的背包 题解]]></title>
    <url>%2F2019%2F07%2F23%2FJoyOI%20%E4%B8%AD%E4%B8%AD%E7%9A%84%E8%83%8C%E5%8C%85%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Description背包的容积为 $m$，$n$ 个物品，每样东西都有自己的价值、体积和个数（个数 $=0$ 表示无限多个）。求最大价值。 数据范围：$1&lt;=n,m&lt;=5500$ Solution最暴力的做法是 $O(n^2m)$ 的，太慢了，怎么办？只要把每个物品都拆开，比如像 $z[i]=13$，我们把这个物品拆成 $1,2,4,6$，每个物品只能选 $1$ 次 具体的拆法是：先按照 $2$ 的次方来拆，直到当前$+2$的下一个次方数 $&gt;z[i]$ ，就按照 $z[i]−2$ 的当前次方数捆绑最后一堆物体 如上例，这 $4$ 个数可以凑出 $1–13$ 的所有数，所以跑一遍 $01$ 背包模板 为什么能凑出? 简单的证明：比如 $z[i]=31$ ，拆出来是 $1,2,4,8,10$，转化成二进制就是： 123456 1 10 100 1000 10000100000 如果右对齐一下，可以看到任意一位都有且仅有一个 $1$。把要凑的数转化成二进制，每一位有 $1$ 的话就加上这一位有 $1$ 的数。 这种情况是 $z[i]$ 正好能被 $2$ 的次方数凑出。如果不能，比如 $37$ ，最后一堆捆绑的物品就是 $6$。当选择 $1–31$ 个物品时，就按照上面的凑法；当选择 $32–37$ 个物品时，就先选择 $6$ 这一堆，然后再按照上面的凑法。 $upd:$ 似乎没有特判个数 $=0$ （无限多个）的情况，不过不影响 $AC$ … Code12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstdio&gt;#define int long longusing namespace std;int n, m, cnt = 0, ans = 0, v[100000], w[100000], f[9001];signed main()&#123; scanf("%lld%lld", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) &#123; int a, b, c, x = 1; scanf("%lld%lld%lld", &amp;a, &amp;b, &amp;c); while(x &lt;= c) &#123; cnt++; v[cnt] = a*x; w[cnt] = b*x; c -= x; x *= 2; &#125; if(c) &#123; cnt++; v[cnt] = a * c; w[cnt] = b * c; &#125; &#125; n = cnt; for(int i = 1; i &lt;= n; i++) &#123; for(int j = m; j &gt;= v[i]; j--) &#123; f[j] = max(f[j], f[j - v[i]] + w[i]); &#125; &#125; for(int i = 1; i &lt;= m; i++) ans = max(ans, f[i]); printf("%lld", ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>dp</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P2470 [SCOI2007]压缩 题解]]></title>
    <url>%2F2019%2F07%2F23%2F%E6%B4%9B%E8%B0%B7%20P2470%20%5BSCOI2007%5D%E5%8E%8B%E7%BC%A9%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Description一个由小写字母组成的字符串，压缩其重复信息。压缩后的字符串除了小写字母外还可以（但不必）包含大写字母 $R$ 与 $M$，其中 $M$ 标记重复串的开始，$R$ 重复从上一个 $M$（如果当前位置左边没有 $M$，则从串的开始算起）开始的解压结果（称为缓冲串）。 串 $bcdcdcdcd$ 的解压过程： 数据范围：$1&lt;=n&lt;=50$ Solution设 $f[i][j]$ 为当前处理到第 $i$ 个字符，上个 $M$ 放在了第 $j$ 个字符之后的最小长度。更新的时候使用刷表法。 有三种情况： $1.$ 什么也不做：$f[i+1][j]=min(f[i+1][j],f[i][j]+1)$ $2.$ 在后面放一个 $M$：$f[i][i]=min(f[i][i],f[i][j]+1)$ $3.$ 在后面放一个 $R$: $f[2i+j][j]=min(f[2i+j][j],f[i][j]+1)$ 注意，这里需要判断一下区间 $(j,i]$ 和区间 $(i,i*2-j]$ 是不是完全相同。完全相同才能执行 $3.$这一步。 Code12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;char s[100];int f[60][60], n, ans = 0x3f3f3f3f;bool get(int mid, int len)&#123; if(mid + len &gt; n) return false; for(int k = 1; k &lt;= len; k++) if(s[mid - len + k] != s[mid + k]) return false; return true;&#125;int main()&#123; scanf("%s", s + 1); memset(f, 0x3f, sizeof(f)); n = strlen(s + 1); f[0][0] = 0; for(int i = 0; i &lt;= n; i++) &#123; for(int j = 0; j &lt;= i; j++) &#123; f[i][i] = min(f[i][i],f[i][j] + 1); f[i + 1][j] = min(f[i + 1][j],f[i][j] + 1); if(get(i, i - j)) f[i * 2 - j][j] = min(f[i * 2 - j][j], f[i][j] + 1); &#125; &#125; for(int i = 0; i &lt;= n; i++) ans = min(ans, f[n][i]); printf("%d", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JoyOI 数字三角形2 题解]]></title>
    <url>%2F2019%2F07%2F23%2FJoyOI%20%E6%95%B0%E5%AD%97%E4%B8%89%E8%A7%92%E5%BD%A22%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Description给定数字三角形，要求最后答案 $mod$ $100$ 最大。 数据范围：$n&lt;=25$ Solution设 $bool$ $f[i][j][k]$ 为走到 $(i,j)$ 这个点 $mod$ $100$ 能不能得到 $k$。更新使用刷表法。 Code12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;using namespace std;int n, f[100][100][150], a[50][50];int main()&#123; memset(f, 0, sizeof(f)); scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= i; j++) scanf("%d", &amp;a[i][j]); f[1][1][a[1][1] % 100] = 1; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= i; j++) for(int k = 0; k &lt; 100; k++) if(f[i][j][k]) &#123; f[i + 1][j][(k + a[i + 1][j]) % 100] = 1; f[i + 1][j + 1][(k + a[i + 1][j + 1]) % 100] = 1; &#125; int ans = -0x3f3f3f3f; for(int i = 1; i &lt;= n; i++) for(int k = 0; k &lt; 100; k++) if(f[n][i][k]) ans = max(ans, k); printf("%d", ans); return 0;&#125;]]></content>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P4302 [SCOI2003]字符串折叠 题解]]></title>
    <url>%2F2019%2F07%2F23%2F%E6%B4%9B%E8%B0%B7%20P4302%20%5BSCOI2003%5D%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8A%98%E5%8F%A0%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Description折叠的定义如下： $1.$ 一个字符串可以看成它自身的折叠。记作 $S=S$. $2.$ $X(S)$ 是 $X(X&gt;1)$ 个 $S$ 连接在一起的串的折叠。记作 $X(S)=SSSS…S$ ( $X$ 个 $S$ )。 如果 $A=A’$, $B=B’$，则 $AB=A’B’$ 例如，因为 $3(A)=AAA$, $2(B)=BB$，所以 $3(A)C2(B)=AAACBB$，而 $2(3(A)C)2(B)=AAACAAACBB$ 求给定字符串的最短折叠。 数据范围：$len&lt;=100$ Solution设 $f[i][j]$ 为表示区间 $[i,j]$ 折叠的最小长度。 $get(i,j,k,h)$ 表示区间 $[i,j]$ 和区间 $[k,h]$ 能否折叠。 如果能够折叠：$f[i][j]=min(f[i][j],f[i][k]+2+cal((j-i+1)/(k-i+1)))$ （其中 $cal(x)$ 返回的是 $x$ 的位数） 否则：$f[i][j]=min(f[i][j],f[i][k]+f[k+1][j])$ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 300;string s;int f[N][N], n;bool get(int x1, int y1, int x2, int y2)&#123; if((y2 - x1 + 1) % (y1 - x1 + 1) != 0) return false; int len = y1 - x1 + 1; for(int i = x2; i &lt;= y2; i++) &#123; if(s[i] != s[i - len]) return false; &#125; return true;&#125;int cal(int k)&#123; int ans = 0; while(k) &#123; k /= 10; ans++; &#125; return ans;&#125;int main()&#123; cin &gt;&gt; s; n = s.size(); for(int i = 0; i &lt; n; i++) f[i][i] = 1; for(int i = 1; i &lt; n; i++) &#123; for(int l = 0; l + i &lt; n; l++) &#123; int r = l + i; f[l][r] = r - l + 1; for(int k = l; k &lt; r; k++) &#123; if(!get(l, k, k + 1, r)) f[l][r] = min(f[l][r], f[l][k] + f[k + 1][r]); else f[l][r] = min(f[l][r], f[l][k] + 2 + cal((r - l + 1) / (k - l + 1))); &#125; &#125; &#125; printf("%d", f[0][n - 1]); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>dp</tag>
        <tag>区间dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P4766 [CERC2014]Outer space invaders 题解]]></title>
    <url>%2F2019%2F07%2F23%2F%E6%B4%9B%E8%B0%B7%20P4766%20%5BCERC2014%5DOuter%20space%20invaders%20%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Description有 $n$ 个外星人进攻，第 $i$ 个外星出现时间为 $a_i$ ，距离为 $d_i$ ,必须在时间 $b_i$ 前被消灭。 你的武器可以设置任何给定的功率。如果被设置了功率 $R$，它会摧毁距离在 $R$ 及以内的所有外星人，同时消耗 $R$ 单位的燃料。 求存活条件下最少要消耗多少燃料。 数据范围：$n&lt;=300 , 1&lt;=a_i&lt;b_i&lt;=10000 , 1&lt;=d_i&lt;=10000$ Solution设 $f[i][j]$ 为消灭 $i–j$ 时间内外星人的最少花费。设这段区间最晚出现的外星人编号为 $id$，则转移方程为： $f[i][j]=min(f[i][j],f[i][k-1]+a[id].d+f[k+1][j])$ 如果开二维数组，$10000$ 有点太大。题面只出现了 $300$ 个外星人，可以离散化。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 50005;struct node&#123; int l, r, d;&#125; a[maxn];int T, n, m, t[maxn], cnt, f[700][700];void solve()&#123; cnt = 0; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d%d%d", &amp;a[i].l, &amp;a[i].r, &amp;a[i].d); t[++cnt] = a[i].l; t[++cnt] = a[i].r; &#125; sort(t + 1, t + cnt + 1); m = unique(t + 1, t + cnt + 1) - t - 1; for(int i = 1; i &lt;= n; i++) &#123; a[i].l = lower_bound(t + 1, t + m + 1, a[i].l) - t; a[i].r = lower_bound(t + 1, t + m + 1, a[i].r) - t; &#125; for(int i = 0; i &lt;= m; i++) for(int l = 1; l + i &lt;= m; l++) &#123; int r = l + i, id = 0; for(int j = 1; j &lt;= n; j++) if(a[j].l &gt;= l &amp;&amp; a[j].r &lt;= r &amp;&amp; (!id || a[j].d &gt; a[id].d)) id = j; if(!id) &#123; f[l][r] = 0; continue; &#125; f[l][r] = 0x3f3f3f3f; for(int k = a[id].l; k &lt;= a[id].r; k++) f[l][r] = min(f[l][r], f[l][k - 1] + f[k + 1][r] + a[id].d); &#125; printf("%d\n", f[1][m]);&#125;int main()&#123; scanf("%d", &amp;T); while(T--) solve(); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>区间dp</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[离散化]]></title>
    <url>%2F2019%2F07%2F23%2F%E7%A6%BB%E6%95%A3%E5%8C%96%2F</url>
    <content type="text"><![CDATA[定义离散化，把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。也就是说，我们不关心数据的真实大小，只关心数据的 相对 大小。比如我们要把 $1e5$ 个范围是 $1e9$ 的数进行并查集。 代码12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1000005;int n, m, a[N], t[N];int main()&#123; scanf("%d%d", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); t[i] = a[i]; &#125; sort(t + 1, t + n + 1); m = unique(t + 1, t + n + 1) - t - 1; for(int i = 1; i &lt;= n; i++) a[i] = lower_bound(t + 1, t + m + 1, a[i]) - t; return 0;&#125; 其中 $unique$ 返回的是去重后的 尾地址 ，需要减去首地址才能使用。$lower$_$bound$ 返回的是左闭右开区间 $[first,last)$ 中第一个大于等于 $val$ 的元素地址（也就是说 $last$ 是越界的）]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>离散化</tag>
      </tags>
  </entry>
</search>
